// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  badge: (where?: BadgeWhereInput) => Promise<boolean>;
  ban: (where?: BanWhereInput) => Promise<boolean>;
  bot: (where?: BotWhereInput) => Promise<boolean>;
  catalogFeatured: (where?: CatalogFeaturedWhereInput) => Promise<boolean>;
  catalogItem: (where?: CatalogItemWhereInput) => Promise<boolean>;
  catalogPage: (where?: CatalogPageWhereInput) => Promise<boolean>;
  chatlog: (where?: ChatlogWhereInput) => Promise<boolean>;
  chatlogConsole: (where?: ChatlogConsoleWhereInput) => Promise<boolean>;
  chatlogConsoleInvitations: (
    where?: ChatlogConsoleInvitationsWhereInput
  ) => Promise<boolean>;
  habbo: (where?: HabboWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  navigatorCategory: (where?: NavigatorCategoryWhereInput) => Promise<boolean>;
  navigatorTab: (where?: NavigatorTabWhereInput) => Promise<boolean>;
  news: (where?: NewsWhereInput) => Promise<boolean>;
  room: (where?: RoomWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  badge: (where: BadgeWhereUniqueInput) => BadgeNullablePromise;
  badges: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Badge>;
  badgesConnection: (args?: {
    where?: BadgeWhereInput;
    orderBy?: BadgeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BadgeConnectionPromise;
  ban: (where: BanWhereUniqueInput) => BanNullablePromise;
  bans: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Ban>;
  bansConnection: (args?: {
    where?: BanWhereInput;
    orderBy?: BanOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BanConnectionPromise;
  bot: (where: BotWhereUniqueInput) => BotNullablePromise;
  bots: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bot>;
  botsConnection: (args?: {
    where?: BotWhereInput;
    orderBy?: BotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BotConnectionPromise;
  catalogFeatured: (
    where: CatalogFeaturedWhereUniqueInput
  ) => CatalogFeaturedNullablePromise;
  catalogFeatureds: (args?: {
    where?: CatalogFeaturedWhereInput;
    orderBy?: CatalogFeaturedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogFeatured>;
  catalogFeaturedsConnection: (args?: {
    where?: CatalogFeaturedWhereInput;
    orderBy?: CatalogFeaturedOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogFeaturedConnectionPromise;
  catalogItem: (
    where: CatalogItemWhereUniqueInput
  ) => CatalogItemNullablePromise;
  catalogItems: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogItem>;
  catalogItemsConnection: (args?: {
    where?: CatalogItemWhereInput;
    orderBy?: CatalogItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogItemConnectionPromise;
  catalogPage: (
    where: CatalogPageWhereUniqueInput
  ) => CatalogPageNullablePromise;
  catalogPages: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CatalogPage>;
  catalogPagesConnection: (args?: {
    where?: CatalogPageWhereInput;
    orderBy?: CatalogPageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CatalogPageConnectionPromise;
  chatlog: (where: ChatlogWhereUniqueInput) => ChatlogNullablePromise;
  chatlogs: (args?: {
    where?: ChatlogWhereInput;
    orderBy?: ChatlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Chatlog>;
  chatlogsConnection: (args?: {
    where?: ChatlogWhereInput;
    orderBy?: ChatlogOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConnectionPromise;
  chatlogConsole: (
    where: ChatlogConsoleWhereUniqueInput
  ) => ChatlogConsoleNullablePromise;
  chatlogConsoles: (args?: {
    where?: ChatlogConsoleWhereInput;
    orderBy?: ChatlogConsoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatlogConsole>;
  chatlogConsolesConnection: (args?: {
    where?: ChatlogConsoleWhereInput;
    orderBy?: ChatlogConsoleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConsoleConnectionPromise;
  chatlogConsoleInvitations: (
    where: ChatlogConsoleInvitationsWhereUniqueInput
  ) => ChatlogConsoleInvitationsNullablePromise;
  chatlogConsoleInvitationses: (args?: {
    where?: ChatlogConsoleInvitationsWhereInput;
    orderBy?: ChatlogConsoleInvitationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ChatlogConsoleInvitations>;
  chatlogConsoleInvitationsesConnection: (args?: {
    where?: ChatlogConsoleInvitationsWhereInput;
    orderBy?: ChatlogConsoleInvitationsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatlogConsoleInvitationsConnectionPromise;
  habbo: (where: HabboWhereUniqueInput) => HabboNullablePromise;
  habboes: (args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Habbo>;
  habboesConnection: (args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HabboConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  navigatorCategory: (
    where: NavigatorCategoryWhereUniqueInput
  ) => NavigatorCategoryNullablePromise;
  navigatorCategories: (args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NavigatorCategory>;
  navigatorCategoriesConnection: (args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NavigatorCategoryConnectionPromise;
  navigatorTab: (
    where: NavigatorTabWhereUniqueInput
  ) => NavigatorTabNullablePromise;
  navigatorTabs: (args?: {
    where?: NavigatorTabWhereInput;
    orderBy?: NavigatorTabOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<NavigatorTab>;
  navigatorTabsConnection: (args?: {
    where?: NavigatorTabWhereInput;
    orderBy?: NavigatorTabOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NavigatorTabConnectionPromise;
  news: (where: NewsWhereUniqueInput) => NewsNullablePromise;
  newses: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<News>;
  newsesConnection: (args?: {
    where?: NewsWhereInput;
    orderBy?: NewsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => NewsConnectionPromise;
  room: (where: RoomWhereUniqueInput) => RoomNullablePromise;
  rooms: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Room>;
  roomsConnection: (args?: {
    where?: RoomWhereInput;
    orderBy?: RoomOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RoomConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBadge: (data: BadgeCreateInput) => BadgePromise;
  updateBadge: (args: {
    data: BadgeUpdateInput;
    where: BadgeWhereUniqueInput;
  }) => BadgePromise;
  updateManyBadges: (args: {
    data: BadgeUpdateManyMutationInput;
    where?: BadgeWhereInput;
  }) => BatchPayloadPromise;
  upsertBadge: (args: {
    where: BadgeWhereUniqueInput;
    create: BadgeCreateInput;
    update: BadgeUpdateInput;
  }) => BadgePromise;
  deleteBadge: (where: BadgeWhereUniqueInput) => BadgePromise;
  deleteManyBadges: (where?: BadgeWhereInput) => BatchPayloadPromise;
  createBan: (data: BanCreateInput) => BanPromise;
  updateBan: (args: {
    data: BanUpdateInput;
    where: BanWhereUniqueInput;
  }) => BanPromise;
  updateManyBans: (args: {
    data: BanUpdateManyMutationInput;
    where?: BanWhereInput;
  }) => BatchPayloadPromise;
  upsertBan: (args: {
    where: BanWhereUniqueInput;
    create: BanCreateInput;
    update: BanUpdateInput;
  }) => BanPromise;
  deleteBan: (where: BanWhereUniqueInput) => BanPromise;
  deleteManyBans: (where?: BanWhereInput) => BatchPayloadPromise;
  createBot: (data: BotCreateInput) => BotPromise;
  updateBot: (args: {
    data: BotUpdateInput;
    where: BotWhereUniqueInput;
  }) => BotPromise;
  updateManyBots: (args: {
    data: BotUpdateManyMutationInput;
    where?: BotWhereInput;
  }) => BatchPayloadPromise;
  upsertBot: (args: {
    where: BotWhereUniqueInput;
    create: BotCreateInput;
    update: BotUpdateInput;
  }) => BotPromise;
  deleteBot: (where: BotWhereUniqueInput) => BotPromise;
  deleteManyBots: (where?: BotWhereInput) => BatchPayloadPromise;
  createCatalogFeatured: (
    data: CatalogFeaturedCreateInput
  ) => CatalogFeaturedPromise;
  updateCatalogFeatured: (args: {
    data: CatalogFeaturedUpdateInput;
    where: CatalogFeaturedWhereUniqueInput;
  }) => CatalogFeaturedPromise;
  updateManyCatalogFeatureds: (args: {
    data: CatalogFeaturedUpdateManyMutationInput;
    where?: CatalogFeaturedWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogFeatured: (args: {
    where: CatalogFeaturedWhereUniqueInput;
    create: CatalogFeaturedCreateInput;
    update: CatalogFeaturedUpdateInput;
  }) => CatalogFeaturedPromise;
  deleteCatalogFeatured: (
    where: CatalogFeaturedWhereUniqueInput
  ) => CatalogFeaturedPromise;
  deleteManyCatalogFeatureds: (
    where?: CatalogFeaturedWhereInput
  ) => BatchPayloadPromise;
  createCatalogItem: (data: CatalogItemCreateInput) => CatalogItemPromise;
  updateCatalogItem: (args: {
    data: CatalogItemUpdateInput;
    where: CatalogItemWhereUniqueInput;
  }) => CatalogItemPromise;
  updateManyCatalogItems: (args: {
    data: CatalogItemUpdateManyMutationInput;
    where?: CatalogItemWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogItem: (args: {
    where: CatalogItemWhereUniqueInput;
    create: CatalogItemCreateInput;
    update: CatalogItemUpdateInput;
  }) => CatalogItemPromise;
  deleteCatalogItem: (where: CatalogItemWhereUniqueInput) => CatalogItemPromise;
  deleteManyCatalogItems: (
    where?: CatalogItemWhereInput
  ) => BatchPayloadPromise;
  createCatalogPage: (data: CatalogPageCreateInput) => CatalogPagePromise;
  updateCatalogPage: (args: {
    data: CatalogPageUpdateInput;
    where: CatalogPageWhereUniqueInput;
  }) => CatalogPagePromise;
  updateManyCatalogPages: (args: {
    data: CatalogPageUpdateManyMutationInput;
    where?: CatalogPageWhereInput;
  }) => BatchPayloadPromise;
  upsertCatalogPage: (args: {
    where: CatalogPageWhereUniqueInput;
    create: CatalogPageCreateInput;
    update: CatalogPageUpdateInput;
  }) => CatalogPagePromise;
  deleteCatalogPage: (where: CatalogPageWhereUniqueInput) => CatalogPagePromise;
  deleteManyCatalogPages: (
    where?: CatalogPageWhereInput
  ) => BatchPayloadPromise;
  createChatlog: (data: ChatlogCreateInput) => ChatlogPromise;
  updateChatlog: (args: {
    data: ChatlogUpdateInput;
    where: ChatlogWhereUniqueInput;
  }) => ChatlogPromise;
  updateManyChatlogs: (args: {
    data: ChatlogUpdateManyMutationInput;
    where?: ChatlogWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlog: (args: {
    where: ChatlogWhereUniqueInput;
    create: ChatlogCreateInput;
    update: ChatlogUpdateInput;
  }) => ChatlogPromise;
  deleteChatlog: (where: ChatlogWhereUniqueInput) => ChatlogPromise;
  deleteManyChatlogs: (where?: ChatlogWhereInput) => BatchPayloadPromise;
  createChatlogConsole: (
    data: ChatlogConsoleCreateInput
  ) => ChatlogConsolePromise;
  updateChatlogConsole: (args: {
    data: ChatlogConsoleUpdateInput;
    where: ChatlogConsoleWhereUniqueInput;
  }) => ChatlogConsolePromise;
  updateManyChatlogConsoles: (args: {
    data: ChatlogConsoleUpdateManyMutationInput;
    where?: ChatlogConsoleWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlogConsole: (args: {
    where: ChatlogConsoleWhereUniqueInput;
    create: ChatlogConsoleCreateInput;
    update: ChatlogConsoleUpdateInput;
  }) => ChatlogConsolePromise;
  deleteChatlogConsole: (
    where: ChatlogConsoleWhereUniqueInput
  ) => ChatlogConsolePromise;
  deleteManyChatlogConsoles: (
    where?: ChatlogConsoleWhereInput
  ) => BatchPayloadPromise;
  createChatlogConsoleInvitations: (
    data: ChatlogConsoleInvitationsCreateInput
  ) => ChatlogConsoleInvitationsPromise;
  updateChatlogConsoleInvitations: (args: {
    data: ChatlogConsoleInvitationsUpdateInput;
    where: ChatlogConsoleInvitationsWhereUniqueInput;
  }) => ChatlogConsoleInvitationsPromise;
  updateManyChatlogConsoleInvitationses: (args: {
    data: ChatlogConsoleInvitationsUpdateManyMutationInput;
    where?: ChatlogConsoleInvitationsWhereInput;
  }) => BatchPayloadPromise;
  upsertChatlogConsoleInvitations: (args: {
    where: ChatlogConsoleInvitationsWhereUniqueInput;
    create: ChatlogConsoleInvitationsCreateInput;
    update: ChatlogConsoleInvitationsUpdateInput;
  }) => ChatlogConsoleInvitationsPromise;
  deleteChatlogConsoleInvitations: (
    where: ChatlogConsoleInvitationsWhereUniqueInput
  ) => ChatlogConsoleInvitationsPromise;
  deleteManyChatlogConsoleInvitationses: (
    where?: ChatlogConsoleInvitationsWhereInput
  ) => BatchPayloadPromise;
  createHabbo: (data: HabboCreateInput) => HabboPromise;
  updateHabbo: (args: {
    data: HabboUpdateInput;
    where: HabboWhereUniqueInput;
  }) => HabboPromise;
  updateManyHabboes: (args: {
    data: HabboUpdateManyMutationInput;
    where?: HabboWhereInput;
  }) => BatchPayloadPromise;
  upsertHabbo: (args: {
    where: HabboWhereUniqueInput;
    create: HabboCreateInput;
    update: HabboUpdateInput;
  }) => HabboPromise;
  deleteHabbo: (where: HabboWhereUniqueInput) => HabboPromise;
  deleteManyHabboes: (where?: HabboWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createNavigatorCategory: (
    data: NavigatorCategoryCreateInput
  ) => NavigatorCategoryPromise;
  updateNavigatorCategory: (args: {
    data: NavigatorCategoryUpdateInput;
    where: NavigatorCategoryWhereUniqueInput;
  }) => NavigatorCategoryPromise;
  updateManyNavigatorCategories: (args: {
    data: NavigatorCategoryUpdateManyMutationInput;
    where?: NavigatorCategoryWhereInput;
  }) => BatchPayloadPromise;
  upsertNavigatorCategory: (args: {
    where: NavigatorCategoryWhereUniqueInput;
    create: NavigatorCategoryCreateInput;
    update: NavigatorCategoryUpdateInput;
  }) => NavigatorCategoryPromise;
  deleteNavigatorCategory: (
    where: NavigatorCategoryWhereUniqueInput
  ) => NavigatorCategoryPromise;
  deleteManyNavigatorCategories: (
    where?: NavigatorCategoryWhereInput
  ) => BatchPayloadPromise;
  createNavigatorTab: (data: NavigatorTabCreateInput) => NavigatorTabPromise;
  updateNavigatorTab: (args: {
    data: NavigatorTabUpdateInput;
    where: NavigatorTabWhereUniqueInput;
  }) => NavigatorTabPromise;
  updateManyNavigatorTabs: (args: {
    data: NavigatorTabUpdateManyMutationInput;
    where?: NavigatorTabWhereInput;
  }) => BatchPayloadPromise;
  upsertNavigatorTab: (args: {
    where: NavigatorTabWhereUniqueInput;
    create: NavigatorTabCreateInput;
    update: NavigatorTabUpdateInput;
  }) => NavigatorTabPromise;
  deleteNavigatorTab: (
    where: NavigatorTabWhereUniqueInput
  ) => NavigatorTabPromise;
  deleteManyNavigatorTabs: (
    where?: NavigatorTabWhereInput
  ) => BatchPayloadPromise;
  createNews: (data: NewsCreateInput) => NewsPromise;
  updateNews: (args: {
    data: NewsUpdateInput;
    where: NewsWhereUniqueInput;
  }) => NewsPromise;
  updateManyNewses: (args: {
    data: NewsUpdateManyMutationInput;
    where?: NewsWhereInput;
  }) => BatchPayloadPromise;
  upsertNews: (args: {
    where: NewsWhereUniqueInput;
    create: NewsCreateInput;
    update: NewsUpdateInput;
  }) => NewsPromise;
  deleteNews: (where: NewsWhereUniqueInput) => NewsPromise;
  deleteManyNewses: (where?: NewsWhereInput) => BatchPayloadPromise;
  createRoom: (data: RoomCreateInput) => RoomPromise;
  updateRoom: (args: {
    data: RoomUpdateInput;
    where: RoomWhereUniqueInput;
  }) => RoomPromise;
  updateManyRooms: (args: {
    data: RoomUpdateManyMutationInput;
    where?: RoomWhereInput;
  }) => BatchPayloadPromise;
  upsertRoom: (args: {
    where: RoomWhereUniqueInput;
    create: RoomCreateInput;
    update: RoomUpdateInput;
  }) => RoomPromise;
  deleteRoom: (where: RoomWhereUniqueInput) => RoomPromise;
  deleteManyRooms: (where?: RoomWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  badge: (
    where?: BadgeSubscriptionWhereInput
  ) => BadgeSubscriptionPayloadSubscription;
  ban: (
    where?: BanSubscriptionWhereInput
  ) => BanSubscriptionPayloadSubscription;
  bot: (
    where?: BotSubscriptionWhereInput
  ) => BotSubscriptionPayloadSubscription;
  catalogFeatured: (
    where?: CatalogFeaturedSubscriptionWhereInput
  ) => CatalogFeaturedSubscriptionPayloadSubscription;
  catalogItem: (
    where?: CatalogItemSubscriptionWhereInput
  ) => CatalogItemSubscriptionPayloadSubscription;
  catalogPage: (
    where?: CatalogPageSubscriptionWhereInput
  ) => CatalogPageSubscriptionPayloadSubscription;
  chatlog: (
    where?: ChatlogSubscriptionWhereInput
  ) => ChatlogSubscriptionPayloadSubscription;
  chatlogConsole: (
    where?: ChatlogConsoleSubscriptionWhereInput
  ) => ChatlogConsoleSubscriptionPayloadSubscription;
  chatlogConsoleInvitations: (
    where?: ChatlogConsoleInvitationsSubscriptionWhereInput
  ) => ChatlogConsoleInvitationsSubscriptionPayloadSubscription;
  habbo: (
    where?: HabboSubscriptionWhereInput
  ) => HabboSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  navigatorCategory: (
    where?: NavigatorCategorySubscriptionWhereInput
  ) => NavigatorCategorySubscriptionPayloadSubscription;
  navigatorTab: (
    where?: NavigatorTabSubscriptionWhereInput
  ) => NavigatorTabSubscriptionPayloadSubscription;
  news: (
    where?: NewsSubscriptionWhereInput
  ) => NewsSubscriptionPayloadSubscription;
  room: (
    where?: RoomSubscriptionWhereInput
  ) => RoomSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "furniture_ASC"
  | "furniture_DESC"
  | "type_ASC"
  | "type_DESC"
  | "x_ASC"
  | "x_DESC"
  | "y_ASC"
  | "y_DESC"
  | "z_ASC"
  | "z_DESC"
  | "rotation_ASC"
  | "rotation_DESC"
  | "inventory_ASC"
  | "inventory_DESC";

export type BotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "inventory_ASC"
  | "inventory_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "type_ASC"
  | "type_DESC"
  | "messages_ASC"
  | "messages_DESC"
  | "chatBubble_ASC"
  | "chatBubble_DESC"
  | "chatAuto_ASC"
  | "chatAuto_DESC"
  | "chatRandom_ASC"
  | "chatRandom_DESC"
  | "chatDelay_ASC"
  | "chatDelay_DESC";

export type roomType = "PUBLIC" | "LOCKED" | "PASSWORD" | "HIDDEN";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "pin_ASC"
  | "pin_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type banStatus = "BANNED" | "APPEALING" | "REJECTED";

export type BadgeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "code_ASC"
  | "code_DESC"
  | "description_ASC"
  | "description_DESC";

export type banType = "USER" | "IP" | "MACHINE";

export type NavigatorTabOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "order_ASC"
  | "order_DESC";

export type HabboOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "username_ASC"
  | "username_DESC"
  | "motto_ASC"
  | "motto_DESC"
  | "gender_ASC"
  | "gender_DESC"
  | "figure_ASC"
  | "figure_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "online_ASC"
  | "online_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "home_ASC"
  | "home_DESC"
  | "volume_ASC"
  | "volume_DESC"
  | "appearOffline_ASC"
  | "appearOffline_DESC"
  | "allowTrade_ASC"
  | "allowTrade_DESC"
  | "allowGifts_ASC"
  | "allowGifts_DESC"
  | "allowMimic_ASC"
  | "allowMimic_DESC"
  | "allowFollow_ASC"
  | "allowFollow_DESC"
  | "allowWhisper_ASC"
  | "allowWhisper_DESC"
  | "allowFriendRequests_ASC"
  | "allowFriendRequests_DESC"
  | "allowBotSpeech_ASC"
  | "allowBotSpeech_DESC"
  | "allowPetSpeech_ASC"
  | "allowPetSpeech_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ChatlogConsoleInvitationsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type Gender = "M" | "F";

export type ChatlogOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type CatalogFeaturedOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "image_ASC"
  | "image_DESC"
  | "link_ASC"
  | "link_DESC"
  | "slot_ASC"
  | "slot_DESC"
  | "updated_ASC"
  | "updated_DESC";

export type CatalogItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "page_ASC"
  | "page_DESC"
  | "item_ASC"
  | "item_DESC"
  | "name_ASC"
  | "name_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "limited_ASC"
  | "limited_DESC"
  | "maximum_ASC"
  | "maximum_DESC"
  | "stack_ASC"
  | "stack_DESC"
  | "active_ASC"
  | "active_DESC";

export type CatalogPageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "parent_ASC"
  | "parent_DESC"
  | "type_ASC"
  | "type_DESC"
  | "order_ASC"
  | "order_DESC"
  | "name_ASC"
  | "name_DESC"
  | "caption_ASC"
  | "caption_DESC"
  | "description_ASC"
  | "description_DESC"
  | "icon_ASC"
  | "icon_DESC"
  | "visible_ASC"
  | "visible_DESC"
  | "enabled_ASC"
  | "enabled_DESC"
  | "rank_ASC"
  | "rank_DESC"
  | "club_ASC"
  | "club_DESC"
  | "vip_ASC"
  | "vip_DESC"
  | "body_ASC"
  | "body_DESC";

export type BanOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "reason_ASC"
  | "reason_DESC"
  | "status_ASC"
  | "status_DESC"
  | "type_ASC"
  | "type_DESC"
  | "user_ASC"
  | "user_DESC"
  | "ip_ASC"
  | "ip_DESC"
  | "machine_ASC"
  | "machine_DESC"
  | "by_ASC"
  | "by_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChatlogConsoleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "message_ASC"
  | "message_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type NavigatorCategoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "order_ASC"
  | "order_DESC";

export type NewsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "summary_ASC"
  | "summary_DESC"
  | "body_ASC"
  | "body_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type RoomOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "type_ASC"
  | "type_DESC"
  | "category_ASC"
  | "category_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "map_ASC"
  | "map_DESC"
  | "floorThickness_ASC"
  | "floorThickness_DESC"
  | "wallThickness_ASC"
  | "wallThickness_DESC"
  | "wallHeight_ASC"
  | "wallHeight_DESC"
  | "hideWalls_ASC"
  | "hideWalls_DESC"
  | "hideWired_ASC"
  | "hideWired_DESC"
  | "currentUsers_ASC"
  | "currentUsers_DESC"
  | "maxUsers_ASC"
  | "maxUsers_DESC"
  | "allowPets_ASC"
  | "allowPets_DESC"
  | "allowPetsEating_ASC"
  | "allowPetsEating_DESC";

export interface CatalogFeaturedUpdateManyMutationInput {
  caption?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  slot?: Maybe<Int>;
}

export type BadgeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  code?: Maybe<String>;
}>;

export interface NavigatorCategoryUpdateInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
  parent?: Maybe<NavigatorTabUpdateOneWithoutCategoriesInput>;
}

export interface ChatlogConsoleCreateInput {
  id?: Maybe<ID_Input>;
  from: HabboCreateOneInput;
  to: HabboCreateOneInput;
  message?: Maybe<String>;
}

export interface NavigatorTabCreateWithoutCategoriesInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface UserCreateWithoutHabbosInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface NavigatorTabCreateOneWithoutCategoriesInput {
  create?: Maybe<NavigatorTabCreateWithoutCategoriesInput>;
  connect?: Maybe<NavigatorTabWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NavigatorCategoryCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
  parent?: Maybe<NavigatorTabCreateOneWithoutCategoriesInput>;
}

export interface NewsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NewsWhereInput>;
  AND?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  OR?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
  NOT?: Maybe<NewsSubscriptionWhereInput[] | NewsSubscriptionWhereInput>;
}

export type NewsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface NavigatorTabSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NavigatorTabWhereInput>;
  AND?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
  OR?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
  NOT?: Maybe<
    NavigatorTabSubscriptionWhereInput[] | NavigatorTabSubscriptionWhereInput
  >;
}

export interface ItemUpdateManyMutationInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface NavigatorCategorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<NavigatorCategoryWhereInput>;
  AND?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | NavigatorCategorySubscriptionWhereInput[]
    | NavigatorCategorySubscriptionWhereInput
  >;
}

export interface NewsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  summary?: Maybe<String>;
  summary_not?: Maybe<String>;
  summary_in?: Maybe<String[] | String>;
  summary_not_in?: Maybe<String[] | String>;
  summary_lt?: Maybe<String>;
  summary_lte?: Maybe<String>;
  summary_gt?: Maybe<String>;
  summary_gte?: Maybe<String>;
  summary_contains?: Maybe<String>;
  summary_not_contains?: Maybe<String>;
  summary_starts_with?: Maybe<String>;
  summary_not_starts_with?: Maybe<String>;
  summary_ends_with?: Maybe<String>;
  summary_not_ends_with?: Maybe<String>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  OR?: Maybe<NewsWhereInput[] | NewsWhereInput>;
  NOT?: Maybe<NewsWhereInput[] | NewsWhereInput>;
}

export interface HabboSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HabboWhereInput>;
  AND?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
  OR?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
  NOT?: Maybe<HabboSubscriptionWhereInput[] | HabboSubscriptionWhereInput>;
}

export interface RoomUpsertWithoutItemsInput {
  update: RoomUpdateWithoutItemsDataInput;
  create: RoomCreateWithoutItemsInput;
}

export type CatalogItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoomUpdateWithoutItemsDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
}

export interface CatalogItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  page?: Maybe<Int>;
  page_not?: Maybe<Int>;
  page_in?: Maybe<Int[] | Int>;
  page_not_in?: Maybe<Int[] | Int>;
  page_lt?: Maybe<Int>;
  page_lte?: Maybe<Int>;
  page_gt?: Maybe<Int>;
  page_gte?: Maybe<Int>;
  item?: Maybe<Int>;
  item_not?: Maybe<Int>;
  item_in?: Maybe<Int[] | Int>;
  item_not_in?: Maybe<Int[] | Int>;
  item_lt?: Maybe<Int>;
  item_lte?: Maybe<Int>;
  item_gt?: Maybe<Int>;
  item_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  limited_not?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  maximum_not?: Maybe<Int>;
  maximum_in?: Maybe<Int[] | Int>;
  maximum_not_in?: Maybe<Int[] | Int>;
  maximum_lt?: Maybe<Int>;
  maximum_lte?: Maybe<Int>;
  maximum_gt?: Maybe<Int>;
  maximum_gte?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  stack_not?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
  active_not?: Maybe<Boolean>;
  AND?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
  OR?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
  NOT?: Maybe<CatalogItemWhereInput[] | CatalogItemWhereInput>;
}

export interface RoomUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<RoomCreateWithoutItemsInput>;
  update?: Maybe<RoomUpdateWithoutItemsDataInput>;
  upsert?: Maybe<RoomUpsertWithoutItemsInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface CatalogPageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogPageWhereInput>;
  AND?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogPageSubscriptionWhereInput[] | CatalogPageSubscriptionWhereInput
  >;
}

export interface ItemUpdateInput {
  owner?: Maybe<Int>;
  room?: Maybe<RoomUpdateOneRequiredWithoutItemsInput>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface CatalogFeaturedSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogFeaturedWhereInput>;
  AND?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CatalogFeaturedSubscriptionWhereInput[]
    | CatalogFeaturedSubscriptionWhereInput
  >;
}

export type RoomWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BotWhereInput>;
  AND?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  OR?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
  NOT?: Maybe<BotSubscriptionWhereInput[] | BotSubscriptionWhereInput>;
}

export interface BadgeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  code?: Maybe<String>;
  code_not?: Maybe<String>;
  code_in?: Maybe<String[] | String>;
  code_not_in?: Maybe<String[] | String>;
  code_lt?: Maybe<String>;
  code_lte?: Maybe<String>;
  code_gt?: Maybe<String>;
  code_gte?: Maybe<String>;
  code_contains?: Maybe<String>;
  code_not_contains?: Maybe<String>;
  code_starts_with?: Maybe<String>;
  code_not_starts_with?: Maybe<String>;
  code_ends_with?: Maybe<String>;
  code_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  OR?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
  NOT?: Maybe<BadgeWhereInput[] | BadgeWhereInput>;
}

export interface BanSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BanWhereInput>;
  AND?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  OR?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
  NOT?: Maybe<BanSubscriptionWhereInput[] | BanSubscriptionWhereInput>;
}

export interface RoomCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomCreaterightsInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface RoomCreateOneWithoutItemsInput {
  create?: Maybe<RoomCreateWithoutItemsInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export type ChatlogWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  room: RoomCreateOneWithoutItemsInput;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemCreatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface RoomUpdateInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
  items?: Maybe<ItemUpdateManyWithoutRoomInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  vip?: Maybe<Int>;
  vip_not?: Maybe<Int>;
  vip_in?: Maybe<Int[] | Int>;
  vip_not_in?: Maybe<Int[] | Int>;
  vip_lt?: Maybe<Int>;
  vip_lte?: Maybe<Int>;
  vip_gt?: Maybe<Int>;
  vip_gte?: Maybe<Int>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  verified_not?: Maybe<Int>;
  verified_in?: Maybe<Int[] | Int>;
  verified_not_in?: Maybe<Int[] | Int>;
  verified_lt?: Maybe<Int>;
  verified_lte?: Maybe<Int>;
  verified_gt?: Maybe<Int>;
  verified_gte?: Maybe<Int>;
  home?: Maybe<Int>;
  home_not?: Maybe<Int>;
  home_in?: Maybe<Int[] | Int>;
  home_not_in?: Maybe<Int[] | Int>;
  home_lt?: Maybe<Int>;
  home_lte?: Maybe<Int>;
  home_gt?: Maybe<Int>;
  home_gte?: Maybe<Int>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  appearOffline_not?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowTrade_not?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowGifts_not?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowMimic_not?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowFollow_not?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowWhisper_not?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowFriendRequests_not?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowBotSpeech_not?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
  allowPetSpeech_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HabboWhereInput[] | HabboWhereInput>;
  OR?: Maybe<HabboWhereInput[] | HabboWhereInput>;
  NOT?: Maybe<HabboWhereInput[] | HabboWhereInput>;
}

export interface HabboUpdateManyMutationInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface BanWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  reason_not?: Maybe<String>;
  reason_in?: Maybe<String[] | String>;
  reason_not_in?: Maybe<String[] | String>;
  reason_lt?: Maybe<String>;
  reason_lte?: Maybe<String>;
  reason_gt?: Maybe<String>;
  reason_gte?: Maybe<String>;
  reason_contains?: Maybe<String>;
  reason_not_contains?: Maybe<String>;
  reason_starts_with?: Maybe<String>;
  reason_not_starts_with?: Maybe<String>;
  reason_ends_with?: Maybe<String>;
  reason_not_ends_with?: Maybe<String>;
  status?: Maybe<banStatus>;
  status_not?: Maybe<banStatus>;
  status_in?: Maybe<banStatus[] | banStatus>;
  status_not_in?: Maybe<banStatus[] | banStatus>;
  type?: Maybe<banType>;
  type_not?: Maybe<banType>;
  type_in?: Maybe<banType[] | banType>;
  type_not_in?: Maybe<banType[] | banType>;
  user?: Maybe<Int>;
  user_not?: Maybe<Int>;
  user_in?: Maybe<Int[] | Int>;
  user_not_in?: Maybe<Int[] | Int>;
  user_lt?: Maybe<Int>;
  user_lte?: Maybe<Int>;
  user_gt?: Maybe<Int>;
  user_gte?: Maybe<Int>;
  ip?: Maybe<String>;
  ip_not?: Maybe<String>;
  ip_in?: Maybe<String[] | String>;
  ip_not_in?: Maybe<String[] | String>;
  ip_lt?: Maybe<String>;
  ip_lte?: Maybe<String>;
  ip_gt?: Maybe<String>;
  ip_gte?: Maybe<String>;
  ip_contains?: Maybe<String>;
  ip_not_contains?: Maybe<String>;
  ip_starts_with?: Maybe<String>;
  ip_not_starts_with?: Maybe<String>;
  ip_ends_with?: Maybe<String>;
  ip_not_ends_with?: Maybe<String>;
  machine?: Maybe<String>;
  machine_not?: Maybe<String>;
  machine_in?: Maybe<String[] | String>;
  machine_not_in?: Maybe<String[] | String>;
  machine_lt?: Maybe<String>;
  machine_lte?: Maybe<String>;
  machine_gt?: Maybe<String>;
  machine_gte?: Maybe<String>;
  machine_contains?: Maybe<String>;
  machine_not_contains?: Maybe<String>;
  machine_starts_with?: Maybe<String>;
  machine_not_starts_with?: Maybe<String>;
  machine_ends_with?: Maybe<String>;
  machine_not_ends_with?: Maybe<String>;
  by?: Maybe<Int>;
  by_not?: Maybe<Int>;
  by_in?: Maybe<Int[] | Int>;
  by_not_in?: Maybe<Int[] | Int>;
  by_lt?: Maybe<Int>;
  by_lte?: Maybe<Int>;
  by_gt?: Maybe<Int>;
  by_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<BanWhereInput[] | BanWhereInput>;
  OR?: Maybe<BanWhereInput[] | BanWhereInput>;
  NOT?: Maybe<BanWhereInput[] | BanWhereInput>;
}

export interface HabboUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutHabbosInput>;
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboUpdateManyDataInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface ChatlogConsoleInvitationsUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface HabboScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  gender?: Maybe<Gender>;
  gender_not?: Maybe<Gender>;
  gender_in?: Maybe<Gender[] | Gender>;
  gender_not_in?: Maybe<Gender[] | Gender>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  vip?: Maybe<Int>;
  vip_not?: Maybe<Int>;
  vip_in?: Maybe<Int[] | Int>;
  vip_not_in?: Maybe<Int[] | Int>;
  vip_lt?: Maybe<Int>;
  vip_lte?: Maybe<Int>;
  vip_gt?: Maybe<Int>;
  vip_gte?: Maybe<Int>;
  online?: Maybe<Boolean>;
  online_not?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  verified_not?: Maybe<Int>;
  verified_in?: Maybe<Int[] | Int>;
  verified_not_in?: Maybe<Int[] | Int>;
  verified_lt?: Maybe<Int>;
  verified_lte?: Maybe<Int>;
  verified_gt?: Maybe<Int>;
  verified_gte?: Maybe<Int>;
  home?: Maybe<Int>;
  home_not?: Maybe<Int>;
  home_in?: Maybe<Int[] | Int>;
  home_not_in?: Maybe<Int[] | Int>;
  home_lt?: Maybe<Int>;
  home_lte?: Maybe<Int>;
  home_gt?: Maybe<Int>;
  home_gte?: Maybe<Int>;
  volume?: Maybe<Int>;
  volume_not?: Maybe<Int>;
  volume_in?: Maybe<Int[] | Int>;
  volume_not_in?: Maybe<Int[] | Int>;
  volume_lt?: Maybe<Int>;
  volume_lte?: Maybe<Int>;
  volume_gt?: Maybe<Int>;
  volume_gte?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  appearOffline_not?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowTrade_not?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowGifts_not?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowMimic_not?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowFollow_not?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowWhisper_not?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowFriendRequests_not?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowBotSpeech_not?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
  allowPetSpeech_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  OR?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  NOT?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
}

export interface ChatlogConsoleInvitationsUpdateInput {
  from?: Maybe<HabboUpdateOneRequiredInput>;
  to?: Maybe<HabboUpdateOneRequiredInput>;
  message?: Maybe<String>;
  room?: Maybe<RoomUpdateOneRequiredInput>;
}

export interface RoomWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  type?: Maybe<roomType>;
  type_not?: Maybe<roomType>;
  type_in?: Maybe<roomType[] | roomType>;
  type_not_in?: Maybe<roomType[] | roomType>;
  category?: Maybe<Int>;
  category_not?: Maybe<Int>;
  category_in?: Maybe<Int[] | Int>;
  category_not_in?: Maybe<Int[] | Int>;
  category_lt?: Maybe<Int>;
  category_lte?: Maybe<Int>;
  category_gt?: Maybe<Int>;
  category_gte?: Maybe<Int>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  floorThickness?: Maybe<Int>;
  floorThickness_not?: Maybe<Int>;
  floorThickness_in?: Maybe<Int[] | Int>;
  floorThickness_not_in?: Maybe<Int[] | Int>;
  floorThickness_lt?: Maybe<Int>;
  floorThickness_lte?: Maybe<Int>;
  floorThickness_gt?: Maybe<Int>;
  floorThickness_gte?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallThickness_not?: Maybe<Int>;
  wallThickness_in?: Maybe<Int[] | Int>;
  wallThickness_not_in?: Maybe<Int[] | Int>;
  wallThickness_lt?: Maybe<Int>;
  wallThickness_lte?: Maybe<Int>;
  wallThickness_gt?: Maybe<Int>;
  wallThickness_gte?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  wallHeight_not?: Maybe<Int>;
  wallHeight_in?: Maybe<Int[] | Int>;
  wallHeight_not_in?: Maybe<Int[] | Int>;
  wallHeight_lt?: Maybe<Int>;
  wallHeight_lte?: Maybe<Int>;
  wallHeight_gt?: Maybe<Int>;
  wallHeight_gte?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWalls_not?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  hideWired_not?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  currentUsers_not?: Maybe<Int>;
  currentUsers_in?: Maybe<Int[] | Int>;
  currentUsers_not_in?: Maybe<Int[] | Int>;
  currentUsers_lt?: Maybe<Int>;
  currentUsers_lte?: Maybe<Int>;
  currentUsers_gt?: Maybe<Int>;
  currentUsers_gte?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  maxUsers_not?: Maybe<Int>;
  maxUsers_in?: Maybe<Int[] | Int>;
  maxUsers_not_in?: Maybe<Int[] | Int>;
  maxUsers_lt?: Maybe<Int>;
  maxUsers_lte?: Maybe<Int>;
  maxUsers_gt?: Maybe<Int>;
  maxUsers_gte?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPets_not?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  allowPetsEating_not?: Maybe<Boolean>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  AND?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  OR?: Maybe<RoomWhereInput[] | RoomWhereInput>;
  NOT?: Maybe<RoomWhereInput[] | RoomWhereInput>;
}

export interface HabboUpsertWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput;
  update: HabboUpdateWithoutUserDataInput;
  create: HabboCreateWithoutUserInput;
}

export interface ChatlogWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  habbo?: Maybe<HabboWhereInput>;
  room?: Maybe<RoomWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
  OR?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
  NOT?: Maybe<ChatlogWhereInput[] | ChatlogWhereInput>;
}

export interface BadgeCreateInput {
  id?: Maybe<ID_Input>;
  code: String;
  description?: Maybe<String>;
}

export interface HabboUpdateManyWithoutUserInput {
  create?: Maybe<HabboCreateWithoutUserInput[] | HabboCreateWithoutUserInput>;
  delete?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  connect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  set?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  disconnect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
  update?: Maybe<
    | HabboUpdateWithWhereUniqueWithoutUserInput[]
    | HabboUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | HabboUpsertWithWhereUniqueWithoutUserInput[]
    | HabboUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<HabboScalarWhereInput[] | HabboScalarWhereInput>;
  updateMany?: Maybe<
    HabboUpdateManyWithWhereNestedInput[] | HabboUpdateManyWithWhereNestedInput
  >;
}

export interface BadgeUpdateInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface BadgeUpdateManyMutationInput {
  code?: Maybe<String>;
  description?: Maybe<String>;
}

export interface NewsUpdateInput {
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  author?: Maybe<UserUpdateOneInput>;
}

export interface ChatlogConsoleInvitationsCreateInput {
  id?: Maybe<ID_Input>;
  from: HabboCreateOneInput;
  to: HabboCreateOneInput;
  message?: Maybe<String>;
  room: RoomCreateOneInput;
}

export interface HabboCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  username: String;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface ChatlogConsoleUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboCreateManyWithoutUserInput>;
}

export interface BanCreateInput {
  id?: Maybe<ID_Input>;
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export type ChatlogConsoleInvitationsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BanUpdateInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface ChatlogConsoleInvitationsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  from?: Maybe<HabboWhereInput>;
  to?: Maybe<HabboWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  room?: Maybe<RoomWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
  OR?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
  NOT?: Maybe<
    ChatlogConsoleInvitationsWhereInput[] | ChatlogConsoleInvitationsWhereInput
  >;
}

export interface BanUpdateManyMutationInput {
  reason?: Maybe<String>;
  status?: Maybe<banStatus>;
  type?: Maybe<banType>;
  user?: Maybe<Int>;
  ip?: Maybe<String>;
  machine?: Maybe<String>;
  by?: Maybe<Int>;
}

export interface NavigatorCategoryUpdateManyDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BotCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotCreatestateInput>;
  action?: Maybe<BotCreateactionInput>;
  position?: Maybe<BotCreatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface NavigatorCategoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  AND?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  OR?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  NOT?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
}

export interface BotCreatestateInput {
  set?: Maybe<String[] | String>;
}

export interface NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput;
  update: NavigatorCategoryUpdateWithoutParentDataInput;
  create: NavigatorCategoryCreateWithoutParentInput;
}

export interface BotCreateactionInput {
  set?: Maybe<String[] | String>;
}

export interface NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput;
  data: NavigatorCategoryUpdateWithoutParentDataInput;
}

export interface BotCreatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface NavigatorCategoryUpdateManyWithoutParentInput {
  create?: Maybe<
    | NavigatorCategoryCreateWithoutParentInput[]
    | NavigatorCategoryCreateWithoutParentInput
  >;
  delete?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  connect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  set?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  disconnect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
  update?: Maybe<
    | NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput[]
    | NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput
  >;
  upsert?: Maybe<
    | NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput[]
    | NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput
  >;
  deleteMany?: Maybe<
    NavigatorCategoryScalarWhereInput[] | NavigatorCategoryScalarWhereInput
  >;
  updateMany?: Maybe<
    | NavigatorCategoryUpdateManyWithWhereNestedInput[]
    | NavigatorCategoryUpdateManyWithWhereNestedInput
  >;
}

export interface BotUpdateInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface NavigatorCategoryCreateWithoutParentInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BotUpdatestateInput {
  set?: Maybe<String[] | String>;
}

export interface NavigatorCategoryCreateManyWithoutParentInput {
  create?: Maybe<
    | NavigatorCategoryCreateWithoutParentInput[]
    | NavigatorCategoryCreateWithoutParentInput
  >;
  connect?: Maybe<
    NavigatorCategoryWhereUniqueInput[] | NavigatorCategoryWhereUniqueInput
  >;
}

export interface BotUpdateactionInput {
  set?: Maybe<String[] | String>;
}

export interface NavigatorCategoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  parent?: Maybe<NavigatorTabWhereInput>;
  AND?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
  OR?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
  NOT?: Maybe<NavigatorCategoryWhereInput[] | NavigatorCategoryWhereInput>;
}

export interface BotUpdatepositionInput {
  set?: Maybe<Int[] | Int>;
}

export interface NavigatorCategoryUpdateManyMutationInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface BotUpdateManyMutationInput {
  name?: Maybe<String>;
  motto?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  figure?: Maybe<String>;
  type?: Maybe<String>;
  state?: Maybe<BotUpdatestateInput>;
  action?: Maybe<BotUpdateactionInput>;
  position?: Maybe<BotUpdatepositionInput>;
  messages?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
}

export interface NavigatorTabUpdateWithoutCategoriesDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface CatalogFeaturedCreateInput {
  id?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  slot?: Maybe<Int>;
}

export type NavigatorTabWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  order?: Maybe<Int>;
}>;

export interface CatalogFeaturedUpdateInput {
  caption?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  slot?: Maybe<Int>;
}

export interface RoomSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RoomWhereInput>;
  AND?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  OR?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
  NOT?: Maybe<RoomSubscriptionWhereInput[] | RoomSubscriptionWhereInput>;
}

export interface ChatlogConsoleUpdateInput {
  from?: Maybe<HabboUpdateOneRequiredInput>;
  to?: Maybe<HabboUpdateOneRequiredInput>;
  message?: Maybe<String>;
}

export interface CatalogFeaturedWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  slot?: Maybe<Int>;
  slot_not?: Maybe<Int>;
  slot_in?: Maybe<Int[] | Int>;
  slot_not_in?: Maybe<Int[] | Int>;
  slot_lt?: Maybe<Int>;
  slot_lte?: Maybe<Int>;
  slot_gt?: Maybe<Int>;
  slot_gte?: Maybe<Int>;
  updated?: Maybe<DateTimeInput>;
  updated_not?: Maybe<DateTimeInput>;
  updated_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updated_lt?: Maybe<DateTimeInput>;
  updated_lte?: Maybe<DateTimeInput>;
  updated_gt?: Maybe<DateTimeInput>;
  updated_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
  OR?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
  NOT?: Maybe<CatalogFeaturedWhereInput[] | CatalogFeaturedWhereInput>;
}

export interface CatalogItemCreateInput {
  id?: Maybe<ID_Input>;
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export interface ChatlogConsoleInvitationsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogConsoleInvitationsWhereInput>;
  AND?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChatlogConsoleInvitationsSubscriptionWhereInput[]
    | ChatlogConsoleInvitationsSubscriptionWhereInput
  >;
}

export interface CatalogItemUpdateInput {
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export interface ChatlogSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogWhereInput>;
  AND?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
  OR?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
  NOT?: Maybe<ChatlogSubscriptionWhereInput[] | ChatlogSubscriptionWhereInput>;
}

export interface CatalogItemUpdateManyMutationInput {
  page?: Maybe<Int>;
  item?: Maybe<Int>;
  name?: Maybe<String>;
  amount?: Maybe<Int>;
  limited?: Maybe<Boolean>;
  maximum?: Maybe<Int>;
  stack?: Maybe<Boolean>;
  active?: Maybe<Boolean>;
}

export type CatalogPageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CatalogPageCreateInput {
  id?: Maybe<ID_Input>;
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name: String;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface BadgeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BadgeWhereInput>;
  AND?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  OR?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
  NOT?: Maybe<BadgeSubscriptionWhereInput[] | BadgeSubscriptionWhereInput>;
}

export interface CatalogPageUpdateInput {
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface RoomUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
}

export interface CatalogPageUpdateManyMutationInput {
  parent?: Maybe<Int>;
  type?: Maybe<String>;
  order?: Maybe<Int>;
  name?: Maybe<String>;
  caption?: Maybe<String>;
  description?: Maybe<String>;
  icon?: Maybe<String>;
  visible?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  club?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  body?: Maybe<String>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  pin?: Maybe<Int>;
  pin_not?: Maybe<Int>;
  pin_in?: Maybe<Int[] | Int>;
  pin_not_in?: Maybe<Int[] | Int>;
  pin_lt?: Maybe<Int>;
  pin_lte?: Maybe<Int>;
  pin_gt?: Maybe<Int>;
  pin_gte?: Maybe<Int>;
  habbos_every?: Maybe<HabboWhereInput>;
  habbos_some?: Maybe<HabboWhereInput>;
  habbos_none?: Maybe<HabboWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface ChatlogCreateInput {
  id?: Maybe<ID_Input>;
  habbo: HabboCreateOneInput;
  room: RoomCreateOneInput;
  message?: Maybe<String>;
}

export interface HabboUpdateManyWithWhereNestedInput {
  where: HabboScalarWhereInput;
  data: HabboUpdateManyDataInput;
}

export interface HabboCreateOneInput {
  create?: Maybe<HabboCreateInput>;
  connect?: Maybe<HabboWhereUniqueInput>;
}

export type BanWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutHabbosInput;
  username: String;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboUpdateWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput;
  data: HabboUpdateWithoutUserDataInput;
}

export interface UserCreateOneWithoutHabbosInput {
  create?: Maybe<UserCreateWithoutHabbosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type ChatlogConsoleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface BotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  motto?: Maybe<String>;
  motto_not?: Maybe<String>;
  motto_in?: Maybe<String[] | String>;
  motto_not_in?: Maybe<String[] | String>;
  motto_lt?: Maybe<String>;
  motto_lte?: Maybe<String>;
  motto_gt?: Maybe<String>;
  motto_gte?: Maybe<String>;
  motto_contains?: Maybe<String>;
  motto_not_contains?: Maybe<String>;
  motto_starts_with?: Maybe<String>;
  motto_not_starts_with?: Maybe<String>;
  motto_ends_with?: Maybe<String>;
  motto_not_ends_with?: Maybe<String>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  gender?: Maybe<Boolean>;
  gender_not?: Maybe<Boolean>;
  figure?: Maybe<String>;
  figure_not?: Maybe<String>;
  figure_in?: Maybe<String[] | String>;
  figure_not_in?: Maybe<String[] | String>;
  figure_lt?: Maybe<String>;
  figure_lte?: Maybe<String>;
  figure_gt?: Maybe<String>;
  figure_gte?: Maybe<String>;
  figure_contains?: Maybe<String>;
  figure_not_contains?: Maybe<String>;
  figure_starts_with?: Maybe<String>;
  figure_not_starts_with?: Maybe<String>;
  figure_ends_with?: Maybe<String>;
  figure_not_ends_with?: Maybe<String>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  messages?: Maybe<String>;
  messages_not?: Maybe<String>;
  messages_in?: Maybe<String[] | String>;
  messages_not_in?: Maybe<String[] | String>;
  messages_lt?: Maybe<String>;
  messages_lte?: Maybe<String>;
  messages_gt?: Maybe<String>;
  messages_gte?: Maybe<String>;
  messages_contains?: Maybe<String>;
  messages_not_contains?: Maybe<String>;
  messages_starts_with?: Maybe<String>;
  messages_not_starts_with?: Maybe<String>;
  messages_ends_with?: Maybe<String>;
  messages_not_ends_with?: Maybe<String>;
  chatBubble?: Maybe<Int>;
  chatBubble_not?: Maybe<Int>;
  chatBubble_in?: Maybe<Int[] | Int>;
  chatBubble_not_in?: Maybe<Int[] | Int>;
  chatBubble_lt?: Maybe<Int>;
  chatBubble_lte?: Maybe<Int>;
  chatBubble_gt?: Maybe<Int>;
  chatBubble_gte?: Maybe<Int>;
  chatAuto?: Maybe<Int>;
  chatAuto_not?: Maybe<Int>;
  chatAuto_in?: Maybe<Int[] | Int>;
  chatAuto_not_in?: Maybe<Int[] | Int>;
  chatAuto_lt?: Maybe<Int>;
  chatAuto_lte?: Maybe<Int>;
  chatAuto_gt?: Maybe<Int>;
  chatAuto_gte?: Maybe<Int>;
  chatRandom?: Maybe<Boolean>;
  chatRandom_not?: Maybe<Boolean>;
  chatDelay?: Maybe<Int>;
  chatDelay_not?: Maybe<Int>;
  chatDelay_in?: Maybe<Int[] | Int>;
  chatDelay_not_in?: Maybe<Int[] | Int>;
  chatDelay_lt?: Maybe<Int>;
  chatDelay_lte?: Maybe<Int>;
  chatDelay_gt?: Maybe<Int>;
  chatDelay_gte?: Maybe<Int>;
  AND?: Maybe<BotWhereInput[] | BotWhereInput>;
  OR?: Maybe<BotWhereInput[] | BotWhereInput>;
  NOT?: Maybe<BotWhereInput[] | BotWhereInput>;
}

export interface HabboCreateManyWithoutUserInput {
  create?: Maybe<HabboCreateWithoutUserInput[] | HabboCreateWithoutUserInput>;
  connect?: Maybe<HabboWhereUniqueInput[] | HabboWhereUniqueInput>;
}

export interface RoomCreateOneInput {
  create?: Maybe<RoomCreateInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface NewsCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
  author?: Maybe<UserCreateOneInput>;
}

export interface RoomCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomCreaterightsInput>;
  items?: Maybe<ItemCreateManyWithoutRoomInput>;
}

export interface NavigatorCategoryUpdateManyWithWhereNestedInput {
  where: NavigatorCategoryScalarWhereInput;
  data: NavigatorCategoryUpdateManyDataInput;
}

export interface RoomCreaterightsInput {
  set?: Maybe<Int[] | Int>;
}

export interface NavigatorCategoryUpdateWithoutParentDataInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface ItemCreateManyWithoutRoomInput {
  create?: Maybe<ItemCreateWithoutRoomInput[] | ItemCreateWithoutRoomInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface NavigatorTabUpdateInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
  categories?: Maybe<NavigatorCategoryUpdateManyWithoutParentInput>;
}

export interface ItemCreateWithoutRoomInput {
  id?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemCreatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface NavigatorTabCreateInput {
  id?: Maybe<ID_Input>;
  name?: Maybe<String>;
  order?: Maybe<Int>;
  categories?: Maybe<NavigatorCategoryCreateManyWithoutParentInput>;
}

export interface ItemCreatewallPositionInput {
  set?: Maybe<Float[] | Float>;
}

export interface NavigatorTabUpsertWithoutCategoriesInput {
  update: NavigatorTabUpdateWithoutCategoriesDataInput;
  create: NavigatorTabCreateWithoutCategoriesInput;
}

export interface ChatlogUpdateInput {
  habbo?: Maybe<HabboUpdateOneRequiredInput>;
  room?: Maybe<RoomUpdateOneRequiredInput>;
  message?: Maybe<String>;
}

export type BotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface HabboUpdateOneRequiredInput {
  create?: Maybe<HabboCreateInput>;
  update?: Maybe<HabboUpdateDataInput>;
  upsert?: Maybe<HabboUpsertNestedInput>;
  connect?: Maybe<HabboWhereUniqueInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface HabboUpdateDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutHabbosInput>;
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface CatalogItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CatalogItemWhereInput>;
  AND?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
  OR?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CatalogItemSubscriptionWhereInput[] | CatalogItemSubscriptionWhereInput
  >;
}

export interface UserUpdateOneRequiredWithoutHabbosInput {
  create?: Maybe<UserCreateWithoutHabbosInput>;
  update?: Maybe<UserUpdateWithoutHabbosDataInput>;
  upsert?: Maybe<UserUpsertWithoutHabbosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboUpdateManyWithoutUserInput>;
}

export interface UserUpdateWithoutHabbosDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserUpsertWithoutHabbosInput {
  update: UserUpdateWithoutHabbosDataInput;
  create: UserCreateWithoutHabbosInput;
}

export interface HabboUpdateWithoutUserDataInput {
  username?: Maybe<String>;
  motto?: Maybe<String>;
  gender?: Maybe<Gender>;
  figure?: Maybe<String>;
  rank?: Maybe<Int>;
  vip?: Maybe<Int>;
  online?: Maybe<Boolean>;
  verified?: Maybe<Int>;
  home?: Maybe<Int>;
  volume?: Maybe<Int>;
  appearOffline?: Maybe<Boolean>;
  allowTrade?: Maybe<Boolean>;
  allowGifts?: Maybe<Boolean>;
  allowMimic?: Maybe<Boolean>;
  allowFollow?: Maybe<Boolean>;
  allowWhisper?: Maybe<Boolean>;
  allowFriendRequests?: Maybe<Boolean>;
  allowBotSpeech?: Maybe<Boolean>;
  allowPetSpeech?: Maybe<Boolean>;
}

export interface HabboUpsertNestedInput {
  update: HabboUpdateDataInput;
  create: HabboCreateInput;
}

export interface ChatlogConsoleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  from?: Maybe<HabboWhereInput>;
  to?: Maybe<HabboWhereInput>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
  OR?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
  NOT?: Maybe<ChatlogConsoleWhereInput[] | ChatlogConsoleWhereInput>;
}

export interface RoomUpdateOneRequiredInput {
  create?: Maybe<RoomCreateInput>;
  update?: Maybe<RoomUpdateDataInput>;
  upsert?: Maybe<RoomUpsertNestedInput>;
  connect?: Maybe<RoomWhereUniqueInput>;
}

export interface NavigatorTabUpdateManyMutationInput {
  name?: Maybe<String>;
  order?: Maybe<Int>;
}

export interface RoomUpdateDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  type?: Maybe<roomType>;
  category?: Maybe<Int>;
  owner?: Maybe<Int>;
  map?: Maybe<Json>;
  floorThickness?: Maybe<Int>;
  wallThickness?: Maybe<Int>;
  wallHeight?: Maybe<Int>;
  hideWalls?: Maybe<Boolean>;
  hideWired?: Maybe<Boolean>;
  currentUsers?: Maybe<Int>;
  maxUsers?: Maybe<Int>;
  allowPets?: Maybe<Boolean>;
  allowPetsEating?: Maybe<Boolean>;
  rights?: Maybe<RoomUpdaterightsInput>;
  items?: Maybe<ItemUpdateManyWithoutRoomInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RoomUpdaterightsInput {
  set?: Maybe<Int[] | Int>;
}

export interface NavigatorTabWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  categories_every?: Maybe<NavigatorCategoryWhereInput>;
  categories_some?: Maybe<NavigatorCategoryWhereInput>;
  categories_none?: Maybe<NavigatorCategoryWhereInput>;
  AND?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
  OR?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
  NOT?: Maybe<NavigatorTabWhereInput[] | NavigatorTabWhereInput>;
}

export interface ItemUpdateManyWithoutRoomInput {
  create?: Maybe<ItemCreateWithoutRoomInput[] | ItemCreateWithoutRoomInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutRoomInput[]
    | ItemUpdateWithWhereUniqueWithoutRoomInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutRoomInput[]
    | ItemUpsertWithWhereUniqueWithoutRoomInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export type CatalogFeaturedWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemUpdateWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutRoomDataInput;
}

export interface CatalogPageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  parent?: Maybe<Int>;
  parent_not?: Maybe<Int>;
  parent_in?: Maybe<Int[] | Int>;
  parent_not_in?: Maybe<Int[] | Int>;
  parent_lt?: Maybe<Int>;
  parent_lte?: Maybe<Int>;
  parent_gt?: Maybe<Int>;
  parent_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  order?: Maybe<Int>;
  order_not?: Maybe<Int>;
  order_in?: Maybe<Int[] | Int>;
  order_not_in?: Maybe<Int[] | Int>;
  order_lt?: Maybe<Int>;
  order_lte?: Maybe<Int>;
  order_gt?: Maybe<Int>;
  order_gte?: Maybe<Int>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  caption?: Maybe<String>;
  caption_not?: Maybe<String>;
  caption_in?: Maybe<String[] | String>;
  caption_not_in?: Maybe<String[] | String>;
  caption_lt?: Maybe<String>;
  caption_lte?: Maybe<String>;
  caption_gt?: Maybe<String>;
  caption_gte?: Maybe<String>;
  caption_contains?: Maybe<String>;
  caption_not_contains?: Maybe<String>;
  caption_starts_with?: Maybe<String>;
  caption_not_starts_with?: Maybe<String>;
  caption_ends_with?: Maybe<String>;
  caption_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  icon?: Maybe<String>;
  icon_not?: Maybe<String>;
  icon_in?: Maybe<String[] | String>;
  icon_not_in?: Maybe<String[] | String>;
  icon_lt?: Maybe<String>;
  icon_lte?: Maybe<String>;
  icon_gt?: Maybe<String>;
  icon_gte?: Maybe<String>;
  icon_contains?: Maybe<String>;
  icon_not_contains?: Maybe<String>;
  icon_starts_with?: Maybe<String>;
  icon_not_starts_with?: Maybe<String>;
  icon_ends_with?: Maybe<String>;
  icon_not_ends_with?: Maybe<String>;
  visible?: Maybe<Boolean>;
  visible_not?: Maybe<Boolean>;
  enabled?: Maybe<Boolean>;
  enabled_not?: Maybe<Boolean>;
  rank?: Maybe<Int>;
  rank_not?: Maybe<Int>;
  rank_in?: Maybe<Int[] | Int>;
  rank_not_in?: Maybe<Int[] | Int>;
  rank_lt?: Maybe<Int>;
  rank_lte?: Maybe<Int>;
  rank_gt?: Maybe<Int>;
  rank_gte?: Maybe<Int>;
  club?: Maybe<Boolean>;
  club_not?: Maybe<Boolean>;
  vip?: Maybe<Boolean>;
  vip_not?: Maybe<Boolean>;
  body?: Maybe<String>;
  body_not?: Maybe<String>;
  body_in?: Maybe<String[] | String>;
  body_not_in?: Maybe<String[] | String>;
  body_lt?: Maybe<String>;
  body_lte?: Maybe<String>;
  body_gt?: Maybe<String>;
  body_gte?: Maybe<String>;
  body_contains?: Maybe<String>;
  body_not_contains?: Maybe<String>;
  body_starts_with?: Maybe<String>;
  body_not_starts_with?: Maybe<String>;
  body_ends_with?: Maybe<String>;
  body_not_ends_with?: Maybe<String>;
  AND?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  OR?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
  NOT?: Maybe<CatalogPageWhereInput[] | CatalogPageWhereInput>;
}

export interface ItemUpdateWithoutRoomDataInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  room?: Maybe<RoomWhereInput>;
  furniture?: Maybe<Int>;
  furniture_not?: Maybe<Int>;
  furniture_in?: Maybe<Int[] | Int>;
  furniture_not_in?: Maybe<Int[] | Int>;
  furniture_lt?: Maybe<Int>;
  furniture_lte?: Maybe<Int>;
  furniture_gt?: Maybe<Int>;
  furniture_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  rotation?: Maybe<Int>;
  rotation_not?: Maybe<Int>;
  rotation_in?: Maybe<Int[] | Int>;
  rotation_not_in?: Maybe<Int[] | Int>;
  rotation_lt?: Maybe<Int>;
  rotation_lte?: Maybe<Int>;
  rotation_gt?: Maybe<Int>;
  rotation_gte?: Maybe<Int>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface ItemUpdatewallPositionInput {
  set?: Maybe<Float[] | Float>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ItemUpsertWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutRoomDataInput;
  create: ItemCreateWithoutRoomInput;
}

export type NavigatorCategoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  owner?: Maybe<Int>;
  owner_not?: Maybe<Int>;
  owner_in?: Maybe<Int[] | Int>;
  owner_not_in?: Maybe<Int[] | Int>;
  owner_lt?: Maybe<Int>;
  owner_lte?: Maybe<Int>;
  owner_gt?: Maybe<Int>;
  owner_gte?: Maybe<Int>;
  furniture?: Maybe<Int>;
  furniture_not?: Maybe<Int>;
  furniture_in?: Maybe<Int[] | Int>;
  furniture_not_in?: Maybe<Int[] | Int>;
  furniture_lt?: Maybe<Int>;
  furniture_lte?: Maybe<Int>;
  furniture_gt?: Maybe<Int>;
  furniture_gte?: Maybe<Int>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  x?: Maybe<Int>;
  x_not?: Maybe<Int>;
  x_in?: Maybe<Int[] | Int>;
  x_not_in?: Maybe<Int[] | Int>;
  x_lt?: Maybe<Int>;
  x_lte?: Maybe<Int>;
  x_gt?: Maybe<Int>;
  x_gte?: Maybe<Int>;
  y?: Maybe<Int>;
  y_not?: Maybe<Int>;
  y_in?: Maybe<Int[] | Int>;
  y_not_in?: Maybe<Int[] | Int>;
  y_lt?: Maybe<Int>;
  y_lte?: Maybe<Int>;
  y_gt?: Maybe<Int>;
  y_gte?: Maybe<Int>;
  z?: Maybe<Int>;
  z_not?: Maybe<Int>;
  z_in?: Maybe<Int[] | Int>;
  z_not_in?: Maybe<Int[] | Int>;
  z_lt?: Maybe<Int>;
  z_lte?: Maybe<Int>;
  z_gt?: Maybe<Int>;
  z_gte?: Maybe<Int>;
  rotation?: Maybe<Int>;
  rotation_not?: Maybe<Int>;
  rotation_in?: Maybe<Int[] | Int>;
  rotation_not_in?: Maybe<Int[] | Int>;
  rotation_lt?: Maybe<Int>;
  rotation_lte?: Maybe<Int>;
  rotation_gt?: Maybe<Int>;
  rotation_gte?: Maybe<Int>;
  inventory?: Maybe<Boolean>;
  inventory_not?: Maybe<Boolean>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ChatlogConsoleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatlogConsoleWhereInput>;
  AND?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ChatlogConsoleSubscriptionWhereInput[]
    | ChatlogConsoleSubscriptionWhereInput
  >;
}

export interface ChatlogUpdateManyMutationInput {
  message?: Maybe<String>;
}

export interface RoomUpsertNestedInput {
  update: RoomUpdateDataInput;
  create: RoomCreateInput;
}

export interface ItemUpdateManyDataInput {
  owner?: Maybe<Int>;
  furniture?: Maybe<Int>;
  type?: Maybe<String>;
  x?: Maybe<Int>;
  y?: Maybe<Int>;
  z?: Maybe<Int>;
  rotation?: Maybe<Int>;
  wallPosition?: Maybe<ItemUpdatewallPositionInput>;
  inventory?: Maybe<Boolean>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface NewsUpdateManyMutationInput {
  title?: Maybe<String>;
  summary?: Maybe<String>;
  body?: Maybe<String>;
  image?: Maybe<String>;
}

export interface NavigatorTabUpdateOneWithoutCategoriesInput {
  create?: Maybe<NavigatorTabCreateWithoutCategoriesInput>;
  update?: Maybe<NavigatorTabUpdateWithoutCategoriesDataInput>;
  upsert?: Maybe<NavigatorTabUpsertWithoutCategoriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<NavigatorTabWhereUniqueInput>;
}

export type HabboWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface UserUpdateDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  pin?: Maybe<Int>;
  habbos?: Maybe<HabboUpdateManyWithoutUserInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email?: String;
  password?: String;
  pin?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Habbo {
  id: ID_Output;
  username: String;
  motto?: String;
  gender?: Gender;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  appearOffline?: Boolean;
  allowTrade?: Boolean;
  allowGifts?: Boolean;
  allowMimic?: Boolean;
  allowFollow?: Boolean;
  allowWhisper?: Boolean;
  allowFriendRequests?: Boolean;
  allowBotSpeech?: Boolean;
  allowPetSpeech?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface HabboPromise extends Promise<Habbo>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HabboSubscription
  extends Promise<AsyncIterator<Habbo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  username: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  appearOffline: () => Promise<AsyncIterator<Boolean>>;
  allowTrade: () => Promise<AsyncIterator<Boolean>>;
  allowGifts: () => Promise<AsyncIterator<Boolean>>;
  allowMimic: () => Promise<AsyncIterator<Boolean>>;
  allowFollow: () => Promise<AsyncIterator<Boolean>>;
  allowWhisper: () => Promise<AsyncIterator<Boolean>>;
  allowFriendRequests: () => Promise<AsyncIterator<Boolean>>;
  allowBotSpeech: () => Promise<AsyncIterator<Boolean>>;
  allowPetSpeech: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HabboNullablePromise
  extends Promise<Habbo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Bot {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPromise extends Promise<Bot>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotSubscription
  extends Promise<AsyncIterator<Bot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface BotNullablePromise extends Promise<Bot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface Chatlog {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogPromise extends Promise<Chatlog>, Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  room: <T = RoomPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogSubscription
  extends Promise<AsyncIterator<Chatlog>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  habbo: <T = HabboSubscription>() => T;
  room: <T = RoomSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogNullablePromise
  extends Promise<Chatlog | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  habbo: <T = HabboPromise>() => T;
  room: <T = RoomPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface AggregateCatalogPage {
  count: Int;
}

export interface AggregateCatalogPagePromise
  extends Promise<AggregateCatalogPage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogPageSubscription
  extends Promise<AsyncIterator<AggregateCatalogPage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CatalogPageEdge {
  node: CatalogPage;
  cursor: String;
}

export interface CatalogPageEdgePromise
  extends Promise<CatalogPageEdge>,
    Fragmentable {
  node: <T = CatalogPagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogPageEdgeSubscription
  extends Promise<AsyncIterator<CatalogPageEdge>>,
    Fragmentable {
  node: <T = CatalogPageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Badge {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePromise extends Promise<Badge>, Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgeSubscription
  extends Promise<AsyncIterator<Badge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface BadgeNullablePromise
  extends Promise<Badge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface CatalogPageConnection {
  pageInfo: PageInfo;
  edges: CatalogPageEdge[];
}

export interface CatalogPageConnectionPromise
  extends Promise<CatalogPageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogPageEdge>>() => T;
  aggregate: <T = AggregateCatalogPagePromise>() => T;
}

export interface CatalogPageConnectionSubscription
  extends Promise<AsyncIterator<CatalogPageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogPageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogPageSubscription>() => T;
}

export interface RoomEdge {
  node: Room;
  cursor: String;
}

export interface RoomEdgePromise extends Promise<RoomEdge>, Fragmentable {
  node: <T = RoomPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RoomEdgeSubscription
  extends Promise<AsyncIterator<RoomEdge>>,
    Fragmentable {
  node: <T = RoomSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface NewsSubscriptionPayload {
  mutation: MutationType;
  node: News;
  updatedFields: String[];
  previousValues: NewsPreviousValues;
}

export interface NewsSubscriptionPayloadPromise
  extends Promise<NewsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NewsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NewsPreviousValuesPromise>() => T;
}

export interface NewsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NewsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NewsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NewsPreviousValuesSubscription>() => T;
}

export interface AggregateRoom {
  count: Int;
}

export interface AggregateRoomPromise
  extends Promise<AggregateRoom>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRoomSubscription
  extends Promise<AsyncIterator<AggregateRoom>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateNews {
  count: Int;
}

export interface AggregateNewsPromise
  extends Promise<AggregateNews>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNewsSubscription
  extends Promise<AsyncIterator<AggregateNews>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RoomConnection {
  pageInfo: PageInfo;
  edges: RoomEdge[];
}

export interface RoomConnectionPromise
  extends Promise<RoomConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RoomEdge>>() => T;
  aggregate: <T = AggregateRoomPromise>() => T;
}

export interface RoomConnectionSubscription
  extends Promise<AsyncIterator<RoomConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RoomEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRoomSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface NewsEdge {
  node: News;
  cursor: String;
}

export interface NewsEdgePromise extends Promise<NewsEdge>, Fragmentable {
  node: <T = NewsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NewsEdgeSubscription
  extends Promise<AsyncIterator<NewsEdge>>,
    Fragmentable {
  node: <T = NewsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNavigatorTab {
  count: Int;
}

export interface AggregateNavigatorTabPromise
  extends Promise<AggregateNavigatorTab>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNavigatorTabSubscription
  extends Promise<AsyncIterator<AggregateNavigatorTab>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BadgeSubscriptionPayload {
  mutation: MutationType;
  node: Badge;
  updatedFields: String[];
  previousValues: BadgePreviousValues;
}

export interface BadgeSubscriptionPayloadPromise
  extends Promise<BadgeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BadgePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BadgePreviousValuesPromise>() => T;
}

export interface BadgeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BadgeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BadgeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BadgePreviousValuesSubscription>() => T;
}

export interface NavigatorTabConnection {
  pageInfo: PageInfo;
  edges: NavigatorTabEdge[];
}

export interface NavigatorTabConnectionPromise
  extends Promise<NavigatorTabConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NavigatorTabEdge>>() => T;
  aggregate: <T = AggregateNavigatorTabPromise>() => T;
}

export interface NavigatorTabConnectionSubscription
  extends Promise<AsyncIterator<NavigatorTabConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NavigatorTabEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNavigatorTabSubscription>() => T;
}

export interface BadgePreviousValues {
  id: ID_Output;
  code: String;
  description?: String;
}

export interface BadgePreviousValuesPromise
  extends Promise<BadgePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  code: () => Promise<String>;
  description: () => Promise<String>;
}

export interface BadgePreviousValuesSubscription
  extends Promise<AsyncIterator<BadgePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  code: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateNavigatorCategory {
  count: Int;
}

export interface AggregateNavigatorCategoryPromise
  extends Promise<AggregateNavigatorCategory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateNavigatorCategorySubscription
  extends Promise<AsyncIterator<AggregateNavigatorCategory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BanConnection {
  pageInfo: PageInfo;
  edges: BanEdge[];
}

export interface BanConnectionPromise
  extends Promise<BanConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BanEdge>>() => T;
  aggregate: <T = AggregateBanPromise>() => T;
}

export interface BanConnectionSubscription
  extends Promise<AsyncIterator<BanConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BanEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBanSubscription>() => T;
}

export interface NavigatorCategoryConnection {
  pageInfo: PageInfo;
  edges: NavigatorCategoryEdge[];
}

export interface NavigatorCategoryConnectionPromise
  extends Promise<NavigatorCategoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NavigatorCategoryEdge>>() => T;
  aggregate: <T = AggregateNavigatorCategoryPromise>() => T;
}

export interface NavigatorCategoryConnectionSubscription
  extends Promise<AsyncIterator<NavigatorCategoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NavigatorCategoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNavigatorCategorySubscription>() => T;
}

export interface BanSubscriptionPayload {
  mutation: MutationType;
  node: Ban;
  updatedFields: String[];
  previousValues: BanPreviousValues;
}

export interface BanSubscriptionPayloadPromise
  extends Promise<BanSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BanPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BanPreviousValuesPromise>() => T;
}

export interface BanSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BanSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BanSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BanPreviousValuesSubscription>() => T;
}

export interface NavigatorTab {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorTabPromise
  extends Promise<NavigatorTab>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  categories: <T = FragmentableArray<NavigatorCategory>>(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NavigatorTabSubscription
  extends Promise<AsyncIterator<NavigatorTab>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  categories: <
    T = Promise<AsyncIterator<NavigatorCategorySubscription>>
  >(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface NavigatorTabNullablePromise
  extends Promise<NavigatorTab | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  categories: <T = FragmentableArray<NavigatorCategory>>(args?: {
    where?: NavigatorCategoryWhereInput;
    orderBy?: NavigatorCategoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BanPreviousValues {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPreviousValuesPromise
  extends Promise<BanPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanPreviousValuesSubscription
  extends Promise<AsyncIterator<BanPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogPage {
  id: ID_Output;
  parent?: Int;
  type?: String;
  order?: Int;
  name: String;
  caption?: String;
  description?: String;
  icon?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: String;
}

export interface CatalogPagePromise extends Promise<CatalogPage>, Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface CatalogPageSubscription
  extends Promise<AsyncIterator<CatalogPage>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface CatalogPageNullablePromise
  extends Promise<CatalogPage | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface BotSubscriptionPayload {
  mutation: MutationType;
  node: Bot;
  updatedFields: String[];
  previousValues: BotPreviousValues;
}

export interface BotSubscriptionPayloadPromise
  extends Promise<BotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BotPreviousValuesPromise>() => T;
}

export interface BotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BotPreviousValuesSubscription>() => T;
}

export interface HabboEdge {
  node: Habbo;
  cursor: String;
}

export interface HabboEdgePromise extends Promise<HabboEdge>, Fragmentable {
  node: <T = HabboPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HabboEdgeSubscription
  extends Promise<AsyncIterator<HabboEdge>>,
    Fragmentable {
  node: <T = HabboSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BotPreviousValues {
  id: ID_Output;
  name?: String;
  motto?: String;
  inventory?: Boolean;
  owner?: Int;
  gender?: Boolean;
  figure?: String;
  type?: String;
  state: String[];
  action: String[];
  position: Int[];
  messages?: String;
  chatBubble?: Int;
  chatAuto?: Int;
  chatRandom?: Boolean;
  chatDelay?: Int;
}

export interface BotPreviousValuesPromise
  extends Promise<BotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  motto: () => Promise<String>;
  inventory: () => Promise<Boolean>;
  owner: () => Promise<Int>;
  gender: () => Promise<Boolean>;
  figure: () => Promise<String>;
  type: () => Promise<String>;
  state: () => Promise<String[]>;
  action: () => Promise<String[]>;
  position: () => Promise<Int[]>;
  messages: () => Promise<String>;
  chatBubble: () => Promise<Int>;
  chatAuto: () => Promise<Int>;
  chatRandom: () => Promise<Boolean>;
  chatDelay: () => Promise<Int>;
}

export interface BotPreviousValuesSubscription
  extends Promise<AsyncIterator<BotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
  owner: () => Promise<AsyncIterator<Int>>;
  gender: () => Promise<AsyncIterator<Boolean>>;
  figure: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
  state: () => Promise<AsyncIterator<String[]>>;
  action: () => Promise<AsyncIterator<String[]>>;
  position: () => Promise<AsyncIterator<Int[]>>;
  messages: () => Promise<AsyncIterator<String>>;
  chatBubble: () => Promise<AsyncIterator<Int>>;
  chatAuto: () => Promise<AsyncIterator<Int>>;
  chatRandom: () => Promise<AsyncIterator<Boolean>>;
  chatDelay: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateChatlogConsoleInvitations {
  count: Int;
}

export interface AggregateChatlogConsoleInvitationsPromise
  extends Promise<AggregateChatlogConsoleInvitations>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogConsoleInvitationsSubscription
  extends Promise<AsyncIterator<AggregateChatlogConsoleInvitations>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateCatalogItem {
  count: Int;
}

export interface AggregateCatalogItemPromise
  extends Promise<AggregateCatalogItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogItemSubscription
  extends Promise<AsyncIterator<AggregateCatalogItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatlogConsoleInvitationsConnection {
  pageInfo: PageInfo;
  edges: ChatlogConsoleInvitationsEdge[];
}

export interface ChatlogConsoleInvitationsConnectionPromise
  extends Promise<ChatlogConsoleInvitationsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogConsoleInvitationsEdge>>() => T;
  aggregate: <T = AggregateChatlogConsoleInvitationsPromise>() => T;
}

export interface ChatlogConsoleInvitationsConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ChatlogConsoleInvitationsEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateChatlogConsoleInvitationsSubscription>() => T;
}

export interface CatalogFeaturedSubscriptionPayload {
  mutation: MutationType;
  node: CatalogFeatured;
  updatedFields: String[];
  previousValues: CatalogFeaturedPreviousValues;
}

export interface CatalogFeaturedSubscriptionPayloadPromise
  extends Promise<CatalogFeaturedSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogFeaturedPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogFeaturedPreviousValuesPromise>() => T;
}

export interface CatalogFeaturedSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogFeaturedSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogFeaturedSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogFeaturedPreviousValuesSubscription>() => T;
}

export interface ChatlogConsoleInvitations {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsoleInvitationsPromise
  extends Promise<ChatlogConsoleInvitations>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  room: <T = RoomPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitations>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = HabboSubscription>() => T;
  to: <T = HabboSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  room: <T = RoomSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleInvitationsNullablePromise
  extends Promise<ChatlogConsoleInvitations | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  room: <T = RoomPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CatalogFeaturedPreviousValues {
  id: ID_Output;
  caption?: String;
  image?: String;
  link?: String;
  slot?: Int;
  updated?: DateTimeOutput;
}

export interface CatalogFeaturedPreviousValuesPromise
  extends Promise<CatalogFeaturedPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface CatalogFeaturedPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogFeaturedPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  slot: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleEdge {
  node: ChatlogConsole;
  cursor: String;
}

export interface ChatlogConsoleEdgePromise
  extends Promise<ChatlogConsoleEdge>,
    Fragmentable {
  node: <T = ChatlogConsolePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogConsoleEdgeSubscription
  extends Promise<AsyncIterator<ChatlogConsoleEdge>>,
    Fragmentable {
  node: <T = ChatlogConsoleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CatalogItemEdge {
  node: CatalogItem;
  cursor: String;
}

export interface CatalogItemEdgePromise
  extends Promise<CatalogItemEdge>,
    Fragmentable {
  node: <T = CatalogItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogItemEdgeSubscription
  extends Promise<AsyncIterator<CatalogItemEdge>>,
    Fragmentable {
  node: <T = CatalogItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BadgeEdge {
  node: Badge;
  cursor: String;
}

export interface BadgeEdgePromise extends Promise<BadgeEdge>, Fragmentable {
  node: <T = BadgePromise>() => T;
  cursor: () => Promise<String>;
}

export interface BadgeEdgeSubscription
  extends Promise<AsyncIterator<BadgeEdge>>,
    Fragmentable {
  node: <T = BadgeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CatalogItemSubscriptionPayload {
  mutation: MutationType;
  node: CatalogItem;
  updatedFields: String[];
  previousValues: CatalogItemPreviousValues;
}

export interface CatalogItemSubscriptionPayloadPromise
  extends Promise<CatalogItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogItemPreviousValuesPromise>() => T;
}

export interface CatalogItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogItemPreviousValuesSubscription>() => T;
}

export interface AggregateChatlog {
  count: Int;
}

export interface AggregateChatlogPromise
  extends Promise<AggregateChatlog>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogSubscription
  extends Promise<AsyncIterator<AggregateChatlog>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CatalogItemPreviousValues {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPreviousValuesPromise
  extends Promise<CatalogItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemPreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface ChatlogConnection {
  pageInfo: PageInfo;
  edges: ChatlogEdge[];
}

export interface ChatlogConnectionPromise
  extends Promise<ChatlogConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogEdge>>() => T;
  aggregate: <T = AggregateChatlogPromise>() => T;
}

export interface ChatlogConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatlogEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatlogSubscription>() => T;
}

export interface CatalogItemConnection {
  pageInfo: PageInfo;
  edges: CatalogItemEdge[];
}

export interface CatalogItemConnectionPromise
  extends Promise<CatalogItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogItemEdge>>() => T;
  aggregate: <T = AggregateCatalogItemPromise>() => T;
}

export interface CatalogItemConnectionSubscription
  extends Promise<AsyncIterator<CatalogItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogItemSubscription>() => T;
}

export interface RoomPreviousValues {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  owner?: Int;
  map?: Json;
  floorThickness?: Int;
  wallThickness?: Int;
  wallHeight?: Int;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  currentUsers?: Int;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
  rights: Int[];
}

export interface RoomPreviousValuesPromise
  extends Promise<RoomPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
}

export interface RoomPreviousValuesSubscription
  extends Promise<AsyncIterator<RoomPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  wallHeight: () => Promise<AsyncIterator<Int>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  currentUsers: () => Promise<AsyncIterator<Int>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
  rights: () => Promise<AsyncIterator<Int[]>>;
}

export interface CatalogPageSubscriptionPayload {
  mutation: MutationType;
  node: CatalogPage;
  updatedFields: String[];
  previousValues: CatalogPagePreviousValues;
}

export interface CatalogPageSubscriptionPayloadPromise
  extends Promise<CatalogPageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CatalogPagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CatalogPagePreviousValuesPromise>() => T;
}

export interface CatalogPageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CatalogPageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CatalogPageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CatalogPagePreviousValuesSubscription>() => T;
}

export interface RoomSubscriptionPayload {
  mutation: MutationType;
  node: Room;
  updatedFields: String[];
  previousValues: RoomPreviousValues;
}

export interface RoomSubscriptionPayloadPromise
  extends Promise<RoomSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RoomPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RoomPreviousValuesPromise>() => T;
}

export interface RoomSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RoomSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RoomSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RoomPreviousValuesSubscription>() => T;
}

export interface CatalogPagePreviousValues {
  id: ID_Output;
  parent?: Int;
  type?: String;
  order?: Int;
  name: String;
  caption?: String;
  description?: String;
  icon?: String;
  visible?: Boolean;
  enabled?: Boolean;
  rank?: Int;
  club?: Boolean;
  vip?: Boolean;
  body?: String;
}

export interface CatalogPagePreviousValuesPromise
  extends Promise<CatalogPagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  parent: () => Promise<Int>;
  type: () => Promise<String>;
  order: () => Promise<Int>;
  name: () => Promise<String>;
  caption: () => Promise<String>;
  description: () => Promise<String>;
  icon: () => Promise<String>;
  visible: () => Promise<Boolean>;
  enabled: () => Promise<Boolean>;
  rank: () => Promise<Int>;
  club: () => Promise<Boolean>;
  vip: () => Promise<Boolean>;
  body: () => Promise<String>;
}

export interface CatalogPagePreviousValuesSubscription
  extends Promise<AsyncIterator<CatalogPagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  parent: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  caption: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  icon: () => Promise<AsyncIterator<String>>;
  visible: () => Promise<AsyncIterator<Boolean>>;
  enabled: () => Promise<AsyncIterator<Boolean>>;
  rank: () => Promise<AsyncIterator<Int>>;
  club: () => Promise<AsyncIterator<Boolean>>;
  vip: () => Promise<AsyncIterator<Boolean>>;
  body: () => Promise<AsyncIterator<String>>;
}

export interface Room {
  id: ID_Output;
  name: String;
  description?: String;
  type?: roomType;
  category?: Int;
  owner?: Int;
  map?: Json;
  floorThickness?: Int;
  wallThickness?: Int;
  wallHeight?: Int;
  hideWalls?: Boolean;
  hideWired?: Boolean;
  currentUsers?: Int;
  maxUsers?: Int;
  allowPets?: Boolean;
  allowPetsEating?: Boolean;
  rights: Int[];
}

export interface RoomPromise extends Promise<Room>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomSubscription
  extends Promise<AsyncIterator<Room>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<roomType>>;
  category: () => Promise<AsyncIterator<Int>>;
  owner: () => Promise<AsyncIterator<Int>>;
  map: () => Promise<AsyncIterator<Json>>;
  floorThickness: () => Promise<AsyncIterator<Int>>;
  wallThickness: () => Promise<AsyncIterator<Int>>;
  wallHeight: () => Promise<AsyncIterator<Int>>;
  hideWalls: () => Promise<AsyncIterator<Boolean>>;
  hideWired: () => Promise<AsyncIterator<Boolean>>;
  currentUsers: () => Promise<AsyncIterator<Int>>;
  maxUsers: () => Promise<AsyncIterator<Int>>;
  allowPets: () => Promise<AsyncIterator<Boolean>>;
  allowPetsEating: () => Promise<AsyncIterator<Boolean>>;
  rights: () => Promise<AsyncIterator<Int[]>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RoomNullablePromise
  extends Promise<Room | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  type: () => Promise<roomType>;
  category: () => Promise<Int>;
  owner: () => Promise<Int>;
  map: () => Promise<Json>;
  floorThickness: () => Promise<Int>;
  wallThickness: () => Promise<Int>;
  wallHeight: () => Promise<Int>;
  hideWalls: () => Promise<Boolean>;
  hideWired: () => Promise<Boolean>;
  currentUsers: () => Promise<Int>;
  maxUsers: () => Promise<Int>;
  allowPets: () => Promise<Boolean>;
  allowPetsEating: () => Promise<Boolean>;
  rights: () => Promise<Int[]>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface BanEdge {
  node: Ban;
  cursor: String;
}

export interface BanEdgePromise extends Promise<BanEdge>, Fragmentable {
  node: <T = BanPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BanEdgeSubscription
  extends Promise<AsyncIterator<BanEdge>>,
    Fragmentable {
  node: <T = BanSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  email?: String;
  password?: String;
  pin?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  habbos: <T = FragmentableArray<Habbo>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  pin: () => Promise<AsyncIterator<Int>>;
  habbos: <T = Promise<AsyncIterator<HabboSubscription>>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  pin: () => Promise<Int>;
  habbos: <T = FragmentableArray<Habbo>>(args?: {
    where?: HabboWhereInput;
    orderBy?: HabboOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogSubscriptionPayload {
  mutation: MutationType;
  node: Chatlog;
  updatedFields: String[];
  previousValues: ChatlogPreviousValues;
}

export interface ChatlogSubscriptionPayloadPromise
  extends Promise<ChatlogSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogPreviousValuesPromise>() => T;
}

export interface ChatlogSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatlogPreviousValuesSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChatlogPreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogPreviousValuesPromise
  extends Promise<ChatlogPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface News {
  id: ID_Output;
  title?: String;
  summary?: String;
  body?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface NewsPromise extends Promise<News>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsSubscription
  extends Promise<AsyncIterator<News>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NewsNullablePromise
  extends Promise<News | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  author: <T = UserPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CatalogItem {
  id: ID_Output;
  page?: Int;
  item?: Int;
  name?: String;
  amount?: Int;
  limited?: Boolean;
  maximum?: Int;
  stack?: Boolean;
  active?: Boolean;
}

export interface CatalogItemPromise extends Promise<CatalogItem>, Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface CatalogItemSubscription
  extends Promise<AsyncIterator<CatalogItem>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  page: () => Promise<AsyncIterator<Int>>;
  item: () => Promise<AsyncIterator<Int>>;
  name: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  limited: () => Promise<AsyncIterator<Boolean>>;
  maximum: () => Promise<AsyncIterator<Int>>;
  stack: () => Promise<AsyncIterator<Boolean>>;
  active: () => Promise<AsyncIterator<Boolean>>;
}

export interface CatalogItemNullablePromise
  extends Promise<CatalogItem | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  page: () => Promise<Int>;
  item: () => Promise<Int>;
  name: () => Promise<String>;
  amount: () => Promise<Int>;
  limited: () => Promise<Boolean>;
  maximum: () => Promise<Int>;
  stack: () => Promise<Boolean>;
  active: () => Promise<Boolean>;
}

export interface BadgeConnection {
  pageInfo: PageInfo;
  edges: BadgeEdge[];
}

export interface BadgeConnectionPromise
  extends Promise<BadgeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BadgeEdge>>() => T;
  aggregate: <T = AggregateBadgePromise>() => T;
}

export interface BadgeConnectionSubscription
  extends Promise<AsyncIterator<BadgeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BadgeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBadgeSubscription>() => T;
}

export interface ChatlogConsoleSubscriptionPayload {
  mutation: MutationType;
  node: ChatlogConsole;
  updatedFields: String[];
  previousValues: ChatlogConsolePreviousValues;
}

export interface ChatlogConsoleSubscriptionPayloadPromise
  extends Promise<ChatlogConsoleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogConsolePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogConsolePreviousValuesPromise>() => T;
}

export interface ChatlogConsoleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogConsoleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogConsoleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatlogConsolePreviousValuesSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChatlogConsolePreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsolePreviousValuesPromise
  extends Promise<ChatlogConsolePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsolePreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogConsolePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCatalogFeatured {
  count: Int;
}

export interface AggregateCatalogFeaturedPromise
  extends Promise<AggregateCatalogFeatured>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCatalogFeaturedSubscription
  extends Promise<AsyncIterator<AggregateCatalogFeatured>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HabboConnection {
  pageInfo: PageInfo;
  edges: HabboEdge[];
}

export interface HabboConnectionPromise
  extends Promise<HabboConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HabboEdge>>() => T;
  aggregate: <T = AggregateHabboPromise>() => T;
}

export interface HabboConnectionSubscription
  extends Promise<AsyncIterator<HabboConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HabboEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHabboSubscription>() => T;
}

export interface ChatlogConsoleInvitationsSubscriptionPayload {
  mutation: MutationType;
  node: ChatlogConsoleInvitations;
  updatedFields: String[];
  previousValues: ChatlogConsoleInvitationsPreviousValues;
}

export interface ChatlogConsoleInvitationsSubscriptionPayloadPromise
  extends Promise<ChatlogConsoleInvitationsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatlogConsoleInvitationsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatlogConsoleInvitationsPreviousValuesPromise>() => T;
}

export interface ChatlogConsoleInvitationsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatlogConsoleInvitationsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = ChatlogConsoleInvitationsPreviousValuesSubscription
  >() => T;
}

export interface BotConnection {
  pageInfo: PageInfo;
  edges: BotEdge[];
}

export interface BotConnectionPromise
  extends Promise<BotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BotEdge>>() => T;
  aggregate: <T = AggregateBotPromise>() => T;
}

export interface BotConnectionSubscription
  extends Promise<AsyncIterator<BotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBotSubscription>() => T;
}

export interface ChatlogConsoleInvitationsPreviousValues {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsoleInvitationsPreviousValuesPromise
  extends Promise<ChatlogConsoleInvitationsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleConnection {
  pageInfo: PageInfo;
  edges: ChatlogConsoleEdge[];
}

export interface ChatlogConsoleConnectionPromise
  extends Promise<ChatlogConsoleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatlogConsoleEdge>>() => T;
  aggregate: <T = AggregateChatlogConsolePromise>() => T;
}

export interface ChatlogConsoleConnectionSubscription
  extends Promise<AsyncIterator<ChatlogConsoleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatlogConsoleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatlogConsoleSubscription>() => T;
}

export interface CatalogFeaturedEdge {
  node: CatalogFeatured;
  cursor: String;
}

export interface CatalogFeaturedEdgePromise
  extends Promise<CatalogFeaturedEdge>,
    Fragmentable {
  node: <T = CatalogFeaturedPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CatalogFeaturedEdgeSubscription
  extends Promise<AsyncIterator<CatalogFeaturedEdge>>,
    Fragmentable {
  node: <T = CatalogFeaturedSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChatlogEdge {
  node: Chatlog;
  cursor: String;
}

export interface ChatlogEdgePromise extends Promise<ChatlogEdge>, Fragmentable {
  node: <T = ChatlogPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogEdgeSubscription
  extends Promise<AsyncIterator<ChatlogEdge>>,
    Fragmentable {
  node: <T = ChatlogSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HabboSubscriptionPayload {
  mutation: MutationType;
  node: Habbo;
  updatedFields: String[];
  previousValues: HabboPreviousValues;
}

export interface HabboSubscriptionPayloadPromise
  extends Promise<HabboSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HabboPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HabboPreviousValuesPromise>() => T;
}

export interface HabboSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HabboSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HabboSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HabboPreviousValuesSubscription>() => T;
}

export interface Item {
  id: ID_Output;
  owner?: Int;
  furniture?: Int;
  type?: String;
  x?: Int;
  y?: Int;
  z?: Int;
  rotation?: Int;
  wallPosition: Float[];
  inventory?: Boolean;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<Int>>;
  room: <T = RoomSubscription>() => T;
  furniture: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
  rotation: () => Promise<AsyncIterator<Int>>;
  wallPosition: () => Promise<AsyncIterator<Float[]>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  room: <T = RoomPromise>() => T;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface HabboPreviousValues {
  id: ID_Output;
  username: String;
  motto?: String;
  gender?: Gender;
  figure?: String;
  rank?: Int;
  vip?: Int;
  online?: Boolean;
  verified?: Int;
  home?: Int;
  volume?: Int;
  appearOffline?: Boolean;
  allowTrade?: Boolean;
  allowGifts?: Boolean;
  allowMimic?: Boolean;
  allowFollow?: Boolean;
  allowWhisper?: Boolean;
  allowFriendRequests?: Boolean;
  allowBotSpeech?: Boolean;
  allowPetSpeech?: Boolean;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface HabboPreviousValuesPromise
  extends Promise<HabboPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  username: () => Promise<String>;
  motto: () => Promise<String>;
  gender: () => Promise<Gender>;
  figure: () => Promise<String>;
  rank: () => Promise<Int>;
  vip: () => Promise<Int>;
  online: () => Promise<Boolean>;
  verified: () => Promise<Int>;
  home: () => Promise<Int>;
  volume: () => Promise<Int>;
  appearOffline: () => Promise<Boolean>;
  allowTrade: () => Promise<Boolean>;
  allowGifts: () => Promise<Boolean>;
  allowMimic: () => Promise<Boolean>;
  allowFollow: () => Promise<Boolean>;
  allowWhisper: () => Promise<Boolean>;
  allowFriendRequests: () => Promise<Boolean>;
  allowBotSpeech: () => Promise<Boolean>;
  allowPetSpeech: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface HabboPreviousValuesSubscription
  extends Promise<AsyncIterator<HabboPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  username: () => Promise<AsyncIterator<String>>;
  motto: () => Promise<AsyncIterator<String>>;
  gender: () => Promise<AsyncIterator<Gender>>;
  figure: () => Promise<AsyncIterator<String>>;
  rank: () => Promise<AsyncIterator<Int>>;
  vip: () => Promise<AsyncIterator<Int>>;
  online: () => Promise<AsyncIterator<Boolean>>;
  verified: () => Promise<AsyncIterator<Int>>;
  home: () => Promise<AsyncIterator<Int>>;
  volume: () => Promise<AsyncIterator<Int>>;
  appearOffline: () => Promise<AsyncIterator<Boolean>>;
  allowTrade: () => Promise<AsyncIterator<Boolean>>;
  allowGifts: () => Promise<AsyncIterator<Boolean>>;
  allowMimic: () => Promise<AsyncIterator<Boolean>>;
  allowFollow: () => Promise<AsyncIterator<Boolean>>;
  allowWhisper: () => Promise<AsyncIterator<Boolean>>;
  allowFriendRequests: () => Promise<AsyncIterator<Boolean>>;
  allowBotSpeech: () => Promise<AsyncIterator<Boolean>>;
  allowPetSpeech: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BotEdge {
  node: Bot;
  cursor: String;
}

export interface BotEdgePromise extends Promise<BotEdge>, Fragmentable {
  node: <T = BotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BotEdgeSubscription
  extends Promise<AsyncIterator<BotEdge>>,
    Fragmentable {
  node: <T = BotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CatalogFeaturedConnection {
  pageInfo: PageInfo;
  edges: CatalogFeaturedEdge[];
}

export interface CatalogFeaturedConnectionPromise
  extends Promise<CatalogFeaturedConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CatalogFeaturedEdge>>() => T;
  aggregate: <T = AggregateCatalogFeaturedPromise>() => T;
}

export interface CatalogFeaturedConnectionSubscription
  extends Promise<AsyncIterator<CatalogFeaturedConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CatalogFeaturedEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCatalogFeaturedSubscription>() => T;
}

export interface NewsConnection {
  pageInfo: PageInfo;
  edges: NewsEdge[];
}

export interface NewsConnectionPromise
  extends Promise<NewsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<NewsEdge>>() => T;
  aggregate: <T = AggregateNewsPromise>() => T;
}

export interface NewsConnectionSubscription
  extends Promise<AsyncIterator<NewsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<NewsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateNewsSubscription>() => T;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface NavigatorCategoryEdge {
  node: NavigatorCategory;
  cursor: String;
}

export interface NavigatorCategoryEdgePromise
  extends Promise<NavigatorCategoryEdge>,
    Fragmentable {
  node: <T = NavigatorCategoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NavigatorCategoryEdgeSubscription
  extends Promise<AsyncIterator<NavigatorCategoryEdge>>,
    Fragmentable {
  node: <T = NavigatorCategorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ItemPreviousValues {
  id: ID_Output;
  owner?: Int;
  furniture?: Int;
  type?: String;
  x?: Int;
  y?: Int;
  z?: Int;
  rotation?: Int;
  wallPosition: Float[];
  inventory?: Boolean;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  owner: () => Promise<Int>;
  furniture: () => Promise<Int>;
  type: () => Promise<String>;
  x: () => Promise<Int>;
  y: () => Promise<Int>;
  z: () => Promise<Int>;
  rotation: () => Promise<Int>;
  wallPosition: () => Promise<Float[]>;
  inventory: () => Promise<Boolean>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  owner: () => Promise<AsyncIterator<Int>>;
  furniture: () => Promise<AsyncIterator<Int>>;
  type: () => Promise<AsyncIterator<String>>;
  x: () => Promise<AsyncIterator<Int>>;
  y: () => Promise<AsyncIterator<Int>>;
  z: () => Promise<AsyncIterator<Int>>;
  rotation: () => Promise<AsyncIterator<Int>>;
  wallPosition: () => Promise<AsyncIterator<Float[]>>;
  inventory: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateHabbo {
  count: Int;
}

export interface AggregateHabboPromise
  extends Promise<AggregateHabbo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHabboSubscription
  extends Promise<AsyncIterator<AggregateHabbo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateBan {
  count: Int;
}

export interface AggregateBanPromise
  extends Promise<AggregateBan>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBanSubscription
  extends Promise<AsyncIterator<AggregateBan>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateChatlogConsole {
  count: Int;
}

export interface AggregateChatlogConsolePromise
  extends Promise<AggregateChatlogConsole>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatlogConsoleSubscription
  extends Promise<AsyncIterator<AggregateChatlogConsole>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorCategorySubscriptionPayload {
  mutation: MutationType;
  node: NavigatorCategory;
  updatedFields: String[];
  previousValues: NavigatorCategoryPreviousValues;
}

export interface NavigatorCategorySubscriptionPayloadPromise
  extends Promise<NavigatorCategorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NavigatorCategoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NavigatorCategoryPreviousValuesPromise>() => T;
}

export interface NavigatorCategorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NavigatorCategorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NavigatorCategorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NavigatorCategoryPreviousValuesSubscription>() => T;
}

export interface AggregateBadge {
  count: Int;
}

export interface AggregateBadgePromise
  extends Promise<AggregateBadge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBadgeSubscription
  extends Promise<AsyncIterator<AggregateBadge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorCategoryPreviousValues {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorCategoryPreviousValuesPromise
  extends Promise<NavigatorCategoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface NavigatorCategoryPreviousValuesSubscription
  extends Promise<AsyncIterator<NavigatorCategoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface NewsPreviousValues {
  id: ID_Output;
  title?: String;
  summary?: String;
  body?: String;
  image?: String;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface NewsPreviousValuesPromise
  extends Promise<NewsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  summary: () => Promise<String>;
  body: () => Promise<String>;
  image: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface NewsPreviousValuesSubscription
  extends Promise<AsyncIterator<NewsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  summary: () => Promise<AsyncIterator<String>>;
  body: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface NavigatorCategory {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorCategoryPromise
  extends Promise<NavigatorCategory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  parent: <T = NavigatorTabPromise>() => T;
}

export interface NavigatorCategorySubscription
  extends Promise<AsyncIterator<NavigatorCategory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
  parent: <T = NavigatorTabSubscription>() => T;
}

export interface NavigatorCategoryNullablePromise
  extends Promise<NavigatorCategory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
  parent: <T = NavigatorTabPromise>() => T;
}

export interface AggregateBot {
  count: Int;
}

export interface AggregateBotPromise
  extends Promise<AggregateBot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBotSubscription
  extends Promise<AsyncIterator<AggregateBot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorTabPreviousValues {
  id: ID_Output;
  name?: String;
  order?: Int;
}

export interface NavigatorTabPreviousValuesPromise
  extends Promise<NavigatorTabPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  order: () => Promise<Int>;
}

export interface NavigatorTabPreviousValuesSubscription
  extends Promise<AsyncIterator<NavigatorTabPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  order: () => Promise<AsyncIterator<Int>>;
}

export interface NavigatorTabSubscriptionPayload {
  mutation: MutationType;
  node: NavigatorTab;
  updatedFields: String[];
  previousValues: NavigatorTabPreviousValues;
}

export interface NavigatorTabSubscriptionPayloadPromise
  extends Promise<NavigatorTabSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = NavigatorTabPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = NavigatorTabPreviousValuesPromise>() => T;
}

export interface NavigatorTabSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<NavigatorTabSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = NavigatorTabSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = NavigatorTabPreviousValuesSubscription>() => T;
}

export interface CatalogFeatured {
  id: ID_Output;
  caption?: String;
  image?: String;
  link?: String;
  slot?: Int;
  updated?: DateTimeOutput;
}

export interface CatalogFeaturedPromise
  extends Promise<CatalogFeatured>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface CatalogFeaturedSubscription
  extends Promise<AsyncIterator<CatalogFeatured>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  caption: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  slot: () => Promise<AsyncIterator<Int>>;
  updated: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CatalogFeaturedNullablePromise
  extends Promise<CatalogFeatured | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  caption: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  slot: () => Promise<Int>;
  updated: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleInvitationsEdge {
  node: ChatlogConsoleInvitations;
  cursor: String;
}

export interface ChatlogConsoleInvitationsEdgePromise
  extends Promise<ChatlogConsoleInvitationsEdge>,
    Fragmentable {
  node: <T = ChatlogConsoleInvitationsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatlogConsoleInvitationsEdgeSubscription
  extends Promise<AsyncIterator<ChatlogConsoleInvitationsEdge>>,
    Fragmentable {
  node: <T = ChatlogConsoleInvitationsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface NavigatorTabEdge {
  node: NavigatorTab;
  cursor: String;
}

export interface NavigatorTabEdgePromise
  extends Promise<NavigatorTabEdge>,
    Fragmentable {
  node: <T = NavigatorTabPromise>() => T;
  cursor: () => Promise<String>;
}

export interface NavigatorTabEdgeSubscription
  extends Promise<AsyncIterator<NavigatorTabEdge>>,
    Fragmentable {
  node: <T = NavigatorTabSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Ban {
  id: ID_Output;
  reason?: String;
  status?: banStatus;
  type?: banType;
  user?: Int;
  ip?: String;
  machine?: String;
  by?: Int;
  createdAt?: DateTimeOutput;
  updatedAt?: DateTimeOutput;
}

export interface BanPromise extends Promise<Ban>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface BanSubscription
  extends Promise<AsyncIterator<Ban>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  reason: () => Promise<AsyncIterator<String>>;
  status: () => Promise<AsyncIterator<banStatus>>;
  type: () => Promise<AsyncIterator<banType>>;
  user: () => Promise<AsyncIterator<Int>>;
  ip: () => Promise<AsyncIterator<String>>;
  machine: () => Promise<AsyncIterator<String>>;
  by: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface BanNullablePromise extends Promise<Ban | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  reason: () => Promise<String>;
  status: () => Promise<banStatus>;
  type: () => Promise<banType>;
  user: () => Promise<Int>;
  ip: () => Promise<String>;
  machine: () => Promise<String>;
  by: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsole {
  id: ID_Output;
  message?: String;
  createdAt?: DateTimeOutput;
}

export interface ChatlogConsolePromise
  extends Promise<ChatlogConsole>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ChatlogConsoleSubscription
  extends Promise<AsyncIterator<ChatlogConsole>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  from: <T = HabboSubscription>() => T;
  to: <T = HabboSubscription>() => T;
  message: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ChatlogConsoleNullablePromise
  extends Promise<ChatlogConsole | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  from: <T = HabboPromise>() => T;
  to: <T = HabboPromise>() => T;
  message: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Json = any;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "banType",
    embedded: false
  },
  {
    name: "banStatus",
    embedded: false
  },
  {
    name: "roomType",
    embedded: false
  },
  {
    name: "Gender",
    embedded: false
  },
  {
    name: "Ban",
    embedded: false
  },
  {
    name: "Badge",
    embedded: false
  },
  {
    name: "Bot",
    embedded: false
  },
  {
    name: "CatalogFeatured",
    embedded: false
  },
  {
    name: "CatalogPage",
    embedded: false
  },
  {
    name: "CatalogItem",
    embedded: false
  },
  {
    name: "Chatlog",
    embedded: false
  },
  {
    name: "ChatlogConsole",
    embedded: false
  },
  {
    name: "ChatlogConsoleInvitations",
    embedded: false
  },
  {
    name: "Room",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "NavigatorTab",
    embedded: false
  },
  {
    name: "NavigatorCategory",
    embedded: false
  },
  {
    name: "News",
    embedded: false
  },
  {
    name: "Habbo",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `http://localhost:4466`
});
export const prisma = new Prisma();
