// Code generated by Prisma (prisma@1.23.0-test.3). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateBadge {
  count: Int!
}

type AggregateBan {
  count: Int!
}

type AggregateBot {
  count: Int!
}

type AggregateCatalogFeatured {
  count: Int!
}

type AggregateCatalogItem {
  count: Int!
}

type AggregateCatalogPage {
  count: Int!
}

type AggregateChatlog {
  count: Int!
}

type AggregateChatlogConsole {
  count: Int!
}

type AggregateChatlogConsoleInvitations {
  count: Int!
}

type AggregateHabbo {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateNavigatorCategory {
  count: Int!
}

type AggregateNavigatorTab {
  count: Int!
}

type AggregateNews {
  count: Int!
}

type AggregateRoom {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type Badge {
  id: ID!
  code: String!
  description: String
}

type BadgeConnection {
  pageInfo: PageInfo!
  edges: [BadgeEdge]!
  aggregate: AggregateBadge!
}

input BadgeCreateInput {
  id: ID
  code: String!
  description: String
}

type BadgeEdge {
  node: Badge!
  cursor: String!
}

enum BadgeOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  description_ASC
  description_DESC
}

type BadgePreviousValues {
  id: ID!
  code: String!
  description: String
}

type BadgeSubscriptionPayload {
  mutation: MutationType!
  node: Badge
  updatedFields: [String!]
  previousValues: BadgePreviousValues
}

input BadgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BadgeWhereInput
  AND: [BadgeSubscriptionWhereInput!]
  OR: [BadgeSubscriptionWhereInput!]
  NOT: [BadgeSubscriptionWhereInput!]
}

input BadgeUpdateInput {
  code: String
  description: String
}

input BadgeUpdateManyMutationInput {
  code: String
  description: String
}

input BadgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [BadgeWhereInput!]
  OR: [BadgeWhereInput!]
  NOT: [BadgeWhereInput!]
}

input BadgeWhereUniqueInput {
  id: ID
  code: String
}

type Ban {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type BanConnection {
  pageInfo: PageInfo!
  edges: [BanEdge]!
  aggregate: AggregateBan!
}

input BanCreateInput {
  id: ID
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

type BanEdge {
  node: Ban!
  cursor: String!
}

enum BanOrderByInput {
  id_ASC
  id_DESC
  reason_ASC
  reason_DESC
  status_ASC
  status_DESC
  type_ASC
  type_DESC
  user_ASC
  user_DESC
  ip_ASC
  ip_DESC
  machine_ASC
  machine_DESC
  by_ASC
  by_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type BanPreviousValues {
  id: ID!
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
  createdAt: DateTime
  updatedAt: DateTime
}

enum banStatus {
  BANNED
  APPEALING
  REJECTED
}

type BanSubscriptionPayload {
  mutation: MutationType!
  node: Ban
  updatedFields: [String!]
  previousValues: BanPreviousValues
}

input BanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BanWhereInput
  AND: [BanSubscriptionWhereInput!]
  OR: [BanSubscriptionWhereInput!]
  NOT: [BanSubscriptionWhereInput!]
}

enum banType {
  USER
  IP
  MACHINE
}

input BanUpdateInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanUpdateManyMutationInput {
  reason: String
  status: banStatus
  type: banType
  user: Int
  ip: String
  machine: String
  by: Int
}

input BanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reason: String
  reason_not: String
  reason_in: [String!]
  reason_not_in: [String!]
  reason_lt: String
  reason_lte: String
  reason_gt: String
  reason_gte: String
  reason_contains: String
  reason_not_contains: String
  reason_starts_with: String
  reason_not_starts_with: String
  reason_ends_with: String
  reason_not_ends_with: String
  status: banStatus
  status_not: banStatus
  status_in: [banStatus!]
  status_not_in: [banStatus!]
  type: banType
  type_not: banType
  type_in: [banType!]
  type_not_in: [banType!]
  user: Int
  user_not: Int
  user_in: [Int!]
  user_not_in: [Int!]
  user_lt: Int
  user_lte: Int
  user_gt: Int
  user_gte: Int
  ip: String
  ip_not: String
  ip_in: [String!]
  ip_not_in: [String!]
  ip_lt: String
  ip_lte: String
  ip_gt: String
  ip_gte: String
  ip_contains: String
  ip_not_contains: String
  ip_starts_with: String
  ip_not_starts_with: String
  ip_ends_with: String
  ip_not_ends_with: String
  machine: String
  machine_not: String
  machine_in: [String!]
  machine_not_in: [String!]
  machine_lt: String
  machine_lte: String
  machine_gt: String
  machine_gte: String
  machine_contains: String
  machine_not_contains: String
  machine_starts_with: String
  machine_not_starts_with: String
  machine_ends_with: String
  machine_not_ends_with: String
  by: Int
  by_not: Int
  by_in: [Int!]
  by_not_in: [Int!]
  by_lt: Int
  by_lte: Int
  by_gt: Int
  by_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [BanWhereInput!]
  OR: [BanWhereInput!]
  NOT: [BanWhereInput!]
}

input BanWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type Bot {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotConnection {
  pageInfo: PageInfo!
  edges: [BotEdge]!
  aggregate: AggregateBot!
}

input BotCreateactionInput {
  set: [String!]
}

input BotCreateInput {
  id: ID
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotCreatestateInput
  action: BotCreateactionInput
  position: BotCreatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotCreatepositionInput {
  set: [Int!]
}

input BotCreatestateInput {
  set: [String!]
}

type BotEdge {
  node: Bot!
  cursor: String!
}

enum BotOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  motto_ASC
  motto_DESC
  inventory_ASC
  inventory_DESC
  owner_ASC
  owner_DESC
  gender_ASC
  gender_DESC
  figure_ASC
  figure_DESC
  type_ASC
  type_DESC
  messages_ASC
  messages_DESC
  chatBubble_ASC
  chatBubble_DESC
  chatAuto_ASC
  chatAuto_DESC
  chatRandom_ASC
  chatRandom_DESC
  chatDelay_ASC
  chatDelay_DESC
}

type BotPreviousValues {
  id: ID!
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: [String!]!
  action: [String!]!
  position: [Int!]!
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

type BotSubscriptionPayload {
  mutation: MutationType!
  node: Bot
  updatedFields: [String!]
  previousValues: BotPreviousValues
}

input BotSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: BotWhereInput
  AND: [BotSubscriptionWhereInput!]
  OR: [BotSubscriptionWhereInput!]
  NOT: [BotSubscriptionWhereInput!]
}

input BotUpdateactionInput {
  set: [String!]
}

input BotUpdateInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdateManyMutationInput {
  name: String
  motto: String
  inventory: Boolean
  owner: Int
  gender: Boolean
  figure: String
  type: String
  state: BotUpdatestateInput
  action: BotUpdateactionInput
  position: BotUpdatepositionInput
  messages: String
  chatBubble: Int
  chatAuto: Int
  chatRandom: Boolean
  chatDelay: Int
}

input BotUpdatepositionInput {
  set: [Int!]
}

input BotUpdatestateInput {
  set: [String!]
}

input BotWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  inventory: Boolean
  inventory_not: Boolean
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  gender: Boolean
  gender_not: Boolean
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  messages: String
  messages_not: String
  messages_in: [String!]
  messages_not_in: [String!]
  messages_lt: String
  messages_lte: String
  messages_gt: String
  messages_gte: String
  messages_contains: String
  messages_not_contains: String
  messages_starts_with: String
  messages_not_starts_with: String
  messages_ends_with: String
  messages_not_ends_with: String
  chatBubble: Int
  chatBubble_not: Int
  chatBubble_in: [Int!]
  chatBubble_not_in: [Int!]
  chatBubble_lt: Int
  chatBubble_lte: Int
  chatBubble_gt: Int
  chatBubble_gte: Int
  chatAuto: Int
  chatAuto_not: Int
  chatAuto_in: [Int!]
  chatAuto_not_in: [Int!]
  chatAuto_lt: Int
  chatAuto_lte: Int
  chatAuto_gt: Int
  chatAuto_gte: Int
  chatRandom: Boolean
  chatRandom_not: Boolean
  chatDelay: Int
  chatDelay_not: Int
  chatDelay_in: [Int!]
  chatDelay_not_in: [Int!]
  chatDelay_lt: Int
  chatDelay_lte: Int
  chatDelay_gt: Int
  chatDelay_gte: Int
  AND: [BotWhereInput!]
  OR: [BotWhereInput!]
  NOT: [BotWhereInput!]
}

input BotWhereUniqueInput {
  id: ID
}

type CatalogFeatured {
  id: ID!
  caption: String
  image: String
  link: String
  slot: Int
  updated: DateTime
}

type CatalogFeaturedConnection {
  pageInfo: PageInfo!
  edges: [CatalogFeaturedEdge]!
  aggregate: AggregateCatalogFeatured!
}

input CatalogFeaturedCreateInput {
  id: ID
  caption: String
  image: String
  link: String
  slot: Int
}

type CatalogFeaturedEdge {
  node: CatalogFeatured!
  cursor: String!
}

enum CatalogFeaturedOrderByInput {
  id_ASC
  id_DESC
  caption_ASC
  caption_DESC
  image_ASC
  image_DESC
  link_ASC
  link_DESC
  slot_ASC
  slot_DESC
  updated_ASC
  updated_DESC
}

type CatalogFeaturedPreviousValues {
  id: ID!
  caption: String
  image: String
  link: String
  slot: Int
  updated: DateTime
}

type CatalogFeaturedSubscriptionPayload {
  mutation: MutationType!
  node: CatalogFeatured
  updatedFields: [String!]
  previousValues: CatalogFeaturedPreviousValues
}

input CatalogFeaturedSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogFeaturedWhereInput
  AND: [CatalogFeaturedSubscriptionWhereInput!]
  OR: [CatalogFeaturedSubscriptionWhereInput!]
  NOT: [CatalogFeaturedSubscriptionWhereInput!]
}

input CatalogFeaturedUpdateInput {
  caption: String
  image: String
  link: String
  slot: Int
}

input CatalogFeaturedUpdateManyMutationInput {
  caption: String
  image: String
  link: String
  slot: Int
}

input CatalogFeaturedWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  slot: Int
  slot_not: Int
  slot_in: [Int!]
  slot_not_in: [Int!]
  slot_lt: Int
  slot_lte: Int
  slot_gt: Int
  slot_gte: Int
  updated: DateTime
  updated_not: DateTime
  updated_in: [DateTime!]
  updated_not_in: [DateTime!]
  updated_lt: DateTime
  updated_lte: DateTime
  updated_gt: DateTime
  updated_gte: DateTime
  AND: [CatalogFeaturedWhereInput!]
  OR: [CatalogFeaturedWhereInput!]
  NOT: [CatalogFeaturedWhereInput!]
}

input CatalogFeaturedWhereUniqueInput {
  id: ID
}

type CatalogItem {
  id: ID!
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemConnection {
  pageInfo: PageInfo!
  edges: [CatalogItemEdge]!
  aggregate: AggregateCatalogItem!
}

input CatalogItemCreateInput {
  id: ID
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemEdge {
  node: CatalogItem!
  cursor: String!
}

enum CatalogItemOrderByInput {
  id_ASC
  id_DESC
  page_ASC
  page_DESC
  item_ASC
  item_DESC
  name_ASC
  name_DESC
  amount_ASC
  amount_DESC
  limited_ASC
  limited_DESC
  maximum_ASC
  maximum_DESC
  stack_ASC
  stack_DESC
  active_ASC
  active_DESC
}

type CatalogItemPreviousValues {
  id: ID!
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

type CatalogItemSubscriptionPayload {
  mutation: MutationType!
  node: CatalogItem
  updatedFields: [String!]
  previousValues: CatalogItemPreviousValues
}

input CatalogItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogItemWhereInput
  AND: [CatalogItemSubscriptionWhereInput!]
  OR: [CatalogItemSubscriptionWhereInput!]
  NOT: [CatalogItemSubscriptionWhereInput!]
}

input CatalogItemUpdateInput {
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

input CatalogItemUpdateManyMutationInput {
  page: Int
  item: Int
  name: String
  amount: Int
  limited: Boolean
  maximum: Int
  stack: Boolean
  active: Boolean
}

input CatalogItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  page: Int
  page_not: Int
  page_in: [Int!]
  page_not_in: [Int!]
  page_lt: Int
  page_lte: Int
  page_gt: Int
  page_gte: Int
  item: Int
  item_not: Int
  item_in: [Int!]
  item_not_in: [Int!]
  item_lt: Int
  item_lte: Int
  item_gt: Int
  item_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  limited: Boolean
  limited_not: Boolean
  maximum: Int
  maximum_not: Int
  maximum_in: [Int!]
  maximum_not_in: [Int!]
  maximum_lt: Int
  maximum_lte: Int
  maximum_gt: Int
  maximum_gte: Int
  stack: Boolean
  stack_not: Boolean
  active: Boolean
  active_not: Boolean
  AND: [CatalogItemWhereInput!]
  OR: [CatalogItemWhereInput!]
  NOT: [CatalogItemWhereInput!]
}

input CatalogItemWhereUniqueInput {
  id: ID
}

type CatalogPage {
  id: ID!
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageConnection {
  pageInfo: PageInfo!
  edges: [CatalogPageEdge]!
  aggregate: AggregateCatalogPage!
}

input CatalogPageCreateInput {
  id: ID
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageEdge {
  node: CatalogPage!
  cursor: String!
}

enum CatalogPageOrderByInput {
  id_ASC
  id_DESC
  parent_ASC
  parent_DESC
  type_ASC
  type_DESC
  order_ASC
  order_DESC
  name_ASC
  name_DESC
  caption_ASC
  caption_DESC
  description_ASC
  description_DESC
  icon_ASC
  icon_DESC
  visible_ASC
  visible_DESC
  enabled_ASC
  enabled_DESC
  rank_ASC
  rank_DESC
  club_ASC
  club_DESC
  vip_ASC
  vip_DESC
  body_ASC
  body_DESC
}

type CatalogPagePreviousValues {
  id: ID!
  parent: Int
  type: String
  order: Int
  name: String!
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

type CatalogPageSubscriptionPayload {
  mutation: MutationType!
  node: CatalogPage
  updatedFields: [String!]
  previousValues: CatalogPagePreviousValues
}

input CatalogPageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CatalogPageWhereInput
  AND: [CatalogPageSubscriptionWhereInput!]
  OR: [CatalogPageSubscriptionWhereInput!]
  NOT: [CatalogPageSubscriptionWhereInput!]
}

input CatalogPageUpdateInput {
  parent: Int
  type: String
  order: Int
  name: String
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

input CatalogPageUpdateManyMutationInput {
  parent: Int
  type: String
  order: Int
  name: String
  caption: String
  description: String
  icon: String
  visible: Boolean
  enabled: Boolean
  rank: Int
  club: Boolean
  vip: Boolean
  body: String
}

input CatalogPageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  parent: Int
  parent_not: Int
  parent_in: [Int!]
  parent_not_in: [Int!]
  parent_lt: Int
  parent_lte: Int
  parent_gt: Int
  parent_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  caption: String
  caption_not: String
  caption_in: [String!]
  caption_not_in: [String!]
  caption_lt: String
  caption_lte: String
  caption_gt: String
  caption_gte: String
  caption_contains: String
  caption_not_contains: String
  caption_starts_with: String
  caption_not_starts_with: String
  caption_ends_with: String
  caption_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  icon: String
  icon_not: String
  icon_in: [String!]
  icon_not_in: [String!]
  icon_lt: String
  icon_lte: String
  icon_gt: String
  icon_gte: String
  icon_contains: String
  icon_not_contains: String
  icon_starts_with: String
  icon_not_starts_with: String
  icon_ends_with: String
  icon_not_ends_with: String
  visible: Boolean
  visible_not: Boolean
  enabled: Boolean
  enabled_not: Boolean
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  club: Boolean
  club_not: Boolean
  vip: Boolean
  vip_not: Boolean
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  AND: [CatalogPageWhereInput!]
  OR: [CatalogPageWhereInput!]
  NOT: [CatalogPageWhereInput!]
}

input CatalogPageWhereUniqueInput {
  id: ID
}

type Chatlog {
  id: ID!
  habbo: Habbo!
  room: Room!
  message: String
  createdAt: DateTime
}

type ChatlogConnection {
  pageInfo: PageInfo!
  edges: [ChatlogEdge]!
  aggregate: AggregateChatlog!
}

type ChatlogConsole {
  id: ID!
  from: Habbo!
  to: Habbo!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleConnection {
  pageInfo: PageInfo!
  edges: [ChatlogConsoleEdge]!
  aggregate: AggregateChatlogConsole!
}

input ChatlogConsoleCreateInput {
  id: ID
  from: HabboCreateOneInput!
  to: HabboCreateOneInput!
  message: String
}

type ChatlogConsoleEdge {
  node: ChatlogConsole!
  cursor: String!
}

type ChatlogConsoleInvitations {
  id: ID!
  from: Habbo!
  to: Habbo!
  message: String
  room: Room!
  createdAt: DateTime
}

type ChatlogConsoleInvitationsConnection {
  pageInfo: PageInfo!
  edges: [ChatlogConsoleInvitationsEdge]!
  aggregate: AggregateChatlogConsoleInvitations!
}

input ChatlogConsoleInvitationsCreateInput {
  id: ID
  from: HabboCreateOneInput!
  to: HabboCreateOneInput!
  message: String
  room: RoomCreateOneInput!
}

type ChatlogConsoleInvitationsEdge {
  node: ChatlogConsoleInvitations!
  cursor: String!
}

enum ChatlogConsoleInvitationsOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogConsoleInvitationsPreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleInvitationsSubscriptionPayload {
  mutation: MutationType!
  node: ChatlogConsoleInvitations
  updatedFields: [String!]
  previousValues: ChatlogConsoleInvitationsPreviousValues
}

input ChatlogConsoleInvitationsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogConsoleInvitationsWhereInput
  AND: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
  OR: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
  NOT: [ChatlogConsoleInvitationsSubscriptionWhereInput!]
}

input ChatlogConsoleInvitationsUpdateInput {
  from: HabboUpdateOneRequiredInput
  to: HabboUpdateOneRequiredInput
  message: String
  room: RoomUpdateOneRequiredInput
}

input ChatlogConsoleInvitationsUpdateManyMutationInput {
  message: String
}

input ChatlogConsoleInvitationsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: HabboWhereInput
  to: HabboWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  room: RoomWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogConsoleInvitationsWhereInput!]
  OR: [ChatlogConsoleInvitationsWhereInput!]
  NOT: [ChatlogConsoleInvitationsWhereInput!]
}

input ChatlogConsoleInvitationsWhereUniqueInput {
  id: ID
}

enum ChatlogConsoleOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogConsolePreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogConsoleSubscriptionPayload {
  mutation: MutationType!
  node: ChatlogConsole
  updatedFields: [String!]
  previousValues: ChatlogConsolePreviousValues
}

input ChatlogConsoleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogConsoleWhereInput
  AND: [ChatlogConsoleSubscriptionWhereInput!]
  OR: [ChatlogConsoleSubscriptionWhereInput!]
  NOT: [ChatlogConsoleSubscriptionWhereInput!]
}

input ChatlogConsoleUpdateInput {
  from: HabboUpdateOneRequiredInput
  to: HabboUpdateOneRequiredInput
  message: String
}

input ChatlogConsoleUpdateManyMutationInput {
  message: String
}

input ChatlogConsoleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  from: HabboWhereInput
  to: HabboWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogConsoleWhereInput!]
  OR: [ChatlogConsoleWhereInput!]
  NOT: [ChatlogConsoleWhereInput!]
}

input ChatlogConsoleWhereUniqueInput {
  id: ID
}

input ChatlogCreateInput {
  id: ID
  habbo: HabboCreateOneInput!
  room: RoomCreateOneInput!
  message: String
}

type ChatlogEdge {
  node: Chatlog!
  cursor: String!
}

enum ChatlogOrderByInput {
  id_ASC
  id_DESC
  message_ASC
  message_DESC
  createdAt_ASC
  createdAt_DESC
}

type ChatlogPreviousValues {
  id: ID!
  message: String
  createdAt: DateTime
}

type ChatlogSubscriptionPayload {
  mutation: MutationType!
  node: Chatlog
  updatedFields: [String!]
  previousValues: ChatlogPreviousValues
}

input ChatlogSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatlogWhereInput
  AND: [ChatlogSubscriptionWhereInput!]
  OR: [ChatlogSubscriptionWhereInput!]
  NOT: [ChatlogSubscriptionWhereInput!]
}

input ChatlogUpdateInput {
  habbo: HabboUpdateOneRequiredInput
  room: RoomUpdateOneRequiredInput
  message: String
}

input ChatlogUpdateManyMutationInput {
  message: String
}

input ChatlogWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  habbo: HabboWhereInput
  room: RoomWhereInput
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ChatlogWhereInput!]
  OR: [ChatlogWhereInput!]
  NOT: [ChatlogWhereInput!]
}

input ChatlogWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Gender {
  M
  F
}

type Habbo {
  id: ID!
  user: User!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

type HabboConnection {
  pageInfo: PageInfo!
  edges: [HabboEdge]!
  aggregate: AggregateHabbo!
}

input HabboCreateInput {
  id: ID
  user: UserCreateOneWithoutHabbosInput!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboCreateManyWithoutUserInput {
  create: [HabboCreateWithoutUserInput!]
  connect: [HabboWhereUniqueInput!]
}

input HabboCreateOneInput {
  create: HabboCreateInput
  connect: HabboWhereUniqueInput
}

input HabboCreateWithoutUserInput {
  id: ID
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

type HabboEdge {
  node: Habbo!
  cursor: String!
}

enum HabboOrderByInput {
  id_ASC
  id_DESC
  username_ASC
  username_DESC
  motto_ASC
  motto_DESC
  gender_ASC
  gender_DESC
  figure_ASC
  figure_DESC
  rank_ASC
  rank_DESC
  vip_ASC
  vip_DESC
  online_ASC
  online_DESC
  verified_ASC
  verified_DESC
  home_ASC
  home_DESC
  volume_ASC
  volume_DESC
  appearOffline_ASC
  appearOffline_DESC
  allowTrade_ASC
  allowTrade_DESC
  allowGifts_ASC
  allowGifts_DESC
  allowMimic_ASC
  allowMimic_DESC
  allowFollow_ASC
  allowFollow_DESC
  allowWhisper_ASC
  allowWhisper_DESC
  allowFriendRequests_ASC
  allowFriendRequests_DESC
  allowBotSpeech_ASC
  allowBotSpeech_DESC
  allowPetSpeech_ASC
  allowPetSpeech_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type HabboPreviousValues {
  id: ID!
  username: String!
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
  createdAt: DateTime
  updatedAt: DateTime
}

input HabboScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  vip: Int
  vip_not: Int
  vip_in: [Int!]
  vip_not_in: [Int!]
  vip_lt: Int
  vip_lte: Int
  vip_gt: Int
  vip_gte: Int
  online: Boolean
  online_not: Boolean
  verified: Int
  verified_not: Int
  verified_in: [Int!]
  verified_not_in: [Int!]
  verified_lt: Int
  verified_lte: Int
  verified_gt: Int
  verified_gte: Int
  home: Int
  home_not: Int
  home_in: [Int!]
  home_not_in: [Int!]
  home_lt: Int
  home_lte: Int
  home_gt: Int
  home_gte: Int
  volume: Int
  volume_not: Int
  volume_in: [Int!]
  volume_not_in: [Int!]
  volume_lt: Int
  volume_lte: Int
  volume_gt: Int
  volume_gte: Int
  appearOffline: Boolean
  appearOffline_not: Boolean
  allowTrade: Boolean
  allowTrade_not: Boolean
  allowGifts: Boolean
  allowGifts_not: Boolean
  allowMimic: Boolean
  allowMimic_not: Boolean
  allowFollow: Boolean
  allowFollow_not: Boolean
  allowWhisper: Boolean
  allowWhisper_not: Boolean
  allowFriendRequests: Boolean
  allowFriendRequests_not: Boolean
  allowBotSpeech: Boolean
  allowBotSpeech_not: Boolean
  allowPetSpeech: Boolean
  allowPetSpeech_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HabboScalarWhereInput!]
  OR: [HabboScalarWhereInput!]
  NOT: [HabboScalarWhereInput!]
}

type HabboSubscriptionPayload {
  mutation: MutationType!
  node: Habbo
  updatedFields: [String!]
  previousValues: HabboPreviousValues
}

input HabboSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: HabboWhereInput
  AND: [HabboSubscriptionWhereInput!]
  OR: [HabboSubscriptionWhereInput!]
  NOT: [HabboSubscriptionWhereInput!]
}

input HabboUpdateDataInput {
  user: UserUpdateOneRequiredWithoutHabbosInput
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateInput {
  user: UserUpdateOneRequiredWithoutHabbosInput
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyDataInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyMutationInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateManyWithoutUserInput {
  create: [HabboCreateWithoutUserInput!]
  delete: [HabboWhereUniqueInput!]
  connect: [HabboWhereUniqueInput!]
  set: [HabboWhereUniqueInput!]
  disconnect: [HabboWhereUniqueInput!]
  update: [HabboUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [HabboUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [HabboScalarWhereInput!]
  updateMany: [HabboUpdateManyWithWhereNestedInput!]
}

input HabboUpdateManyWithWhereNestedInput {
  where: HabboScalarWhereInput!
  data: HabboUpdateManyDataInput!
}

input HabboUpdateOneRequiredInput {
  create: HabboCreateInput
  update: HabboUpdateDataInput
  upsert: HabboUpsertNestedInput
  connect: HabboWhereUniqueInput
}

input HabboUpdateWithoutUserDataInput {
  username: String
  motto: String
  gender: Gender
  figure: String
  rank: Int
  vip: Int
  online: Boolean
  verified: Int
  home: Int
  volume: Int
  appearOffline: Boolean
  allowTrade: Boolean
  allowGifts: Boolean
  allowMimic: Boolean
  allowFollow: Boolean
  allowWhisper: Boolean
  allowFriendRequests: Boolean
  allowBotSpeech: Boolean
  allowPetSpeech: Boolean
}

input HabboUpdateWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput!
  data: HabboUpdateWithoutUserDataInput!
}

input HabboUpsertNestedInput {
  update: HabboUpdateDataInput!
  create: HabboCreateInput!
}

input HabboUpsertWithWhereUniqueWithoutUserInput {
  where: HabboWhereUniqueInput!
  update: HabboUpdateWithoutUserDataInput!
  create: HabboCreateWithoutUserInput!
}

input HabboWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  username: String
  username_not: String
  username_in: [String!]
  username_not_in: [String!]
  username_lt: String
  username_lte: String
  username_gt: String
  username_gte: String
  username_contains: String
  username_not_contains: String
  username_starts_with: String
  username_not_starts_with: String
  username_ends_with: String
  username_not_ends_with: String
  motto: String
  motto_not: String
  motto_in: [String!]
  motto_not_in: [String!]
  motto_lt: String
  motto_lte: String
  motto_gt: String
  motto_gte: String
  motto_contains: String
  motto_not_contains: String
  motto_starts_with: String
  motto_not_starts_with: String
  motto_ends_with: String
  motto_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  figure: String
  figure_not: String
  figure_in: [String!]
  figure_not_in: [String!]
  figure_lt: String
  figure_lte: String
  figure_gt: String
  figure_gte: String
  figure_contains: String
  figure_not_contains: String
  figure_starts_with: String
  figure_not_starts_with: String
  figure_ends_with: String
  figure_not_ends_with: String
  rank: Int
  rank_not: Int
  rank_in: [Int!]
  rank_not_in: [Int!]
  rank_lt: Int
  rank_lte: Int
  rank_gt: Int
  rank_gte: Int
  vip: Int
  vip_not: Int
  vip_in: [Int!]
  vip_not_in: [Int!]
  vip_lt: Int
  vip_lte: Int
  vip_gt: Int
  vip_gte: Int
  online: Boolean
  online_not: Boolean
  verified: Int
  verified_not: Int
  verified_in: [Int!]
  verified_not_in: [Int!]
  verified_lt: Int
  verified_lte: Int
  verified_gt: Int
  verified_gte: Int
  home: Int
  home_not: Int
  home_in: [Int!]
  home_not_in: [Int!]
  home_lt: Int
  home_lte: Int
  home_gt: Int
  home_gte: Int
  volume: Int
  volume_not: Int
  volume_in: [Int!]
  volume_not_in: [Int!]
  volume_lt: Int
  volume_lte: Int
  volume_gt: Int
  volume_gte: Int
  appearOffline: Boolean
  appearOffline_not: Boolean
  allowTrade: Boolean
  allowTrade_not: Boolean
  allowGifts: Boolean
  allowGifts_not: Boolean
  allowMimic: Boolean
  allowMimic_not: Boolean
  allowFollow: Boolean
  allowFollow_not: Boolean
  allowWhisper: Boolean
  allowWhisper_not: Boolean
  allowFriendRequests: Boolean
  allowFriendRequests_not: Boolean
  allowBotSpeech: Boolean
  allowBotSpeech_not: Boolean
  allowPetSpeech: Boolean
  allowPetSpeech_not: Boolean
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [HabboWhereInput!]
  OR: [HabboWhereInput!]
  NOT: [HabboWhereInput!]
}

input HabboWhereUniqueInput {
  id: ID
  username: String
}

type Item {
  id: ID!
  owner: Int
  room: Room!
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: [Float!]!
  inventory: Boolean
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  owner: Int
  room: RoomCreateOneWithoutItemsInput!
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemCreatewallPositionInput
  inventory: Boolean
}

input ItemCreateManyWithoutRoomInput {
  create: [ItemCreateWithoutRoomInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreatewallPositionInput {
  set: [Float!]
}

input ItemCreateWithoutRoomInput {
  id: ID
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemCreatewallPositionInput
  inventory: Boolean
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  owner_ASC
  owner_DESC
  furniture_ASC
  furniture_DESC
  type_ASC
  type_DESC
  x_ASC
  x_DESC
  y_ASC
  y_DESC
  z_ASC
  z_DESC
  rotation_ASC
  rotation_DESC
  inventory_ASC
  inventory_DESC
}

type ItemPreviousValues {
  id: ID!
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: [Float!]!
  inventory: Boolean
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  furniture: Int
  furniture_not: Int
  furniture_in: [Int!]
  furniture_not_in: [Int!]
  furniture_lt: Int
  furniture_lte: Int
  furniture_gt: Int
  furniture_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  z: Int
  z_not: Int
  z_in: [Int!]
  z_not_in: [Int!]
  z_lt: Int
  z_lte: Int
  z_gt: Int
  z_gte: Int
  rotation: Int
  rotation_not: Int
  rotation_in: [Int!]
  rotation_not_in: [Int!]
  rotation_lt: Int
  rotation_lte: Int
  rotation_gt: Int
  rotation_gte: Int
  inventory: Boolean
  inventory_not: Boolean
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateInput {
  owner: Int
  room: RoomUpdateOneRequiredWithoutItemsInput
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyDataInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyMutationInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateManyWithoutRoomInput {
  create: [ItemCreateWithoutRoomInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutRoomInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutRoomInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdatewallPositionInput {
  set: [Float!]
}

input ItemUpdateWithoutRoomDataInput {
  owner: Int
  furniture: Int
  type: String
  x: Int
  y: Int
  z: Int
  rotation: Int
  wallPosition: ItemUpdatewallPositionInput
  inventory: Boolean
}

input ItemUpdateWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutRoomDataInput!
}

input ItemUpsertWithWhereUniqueWithoutRoomInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutRoomDataInput!
  create: ItemCreateWithoutRoomInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  room: RoomWhereInput
  furniture: Int
  furniture_not: Int
  furniture_in: [Int!]
  furniture_not_in: [Int!]
  furniture_lt: Int
  furniture_lte: Int
  furniture_gt: Int
  furniture_gte: Int
  type: String
  type_not: String
  type_in: [String!]
  type_not_in: [String!]
  type_lt: String
  type_lte: String
  type_gt: String
  type_gte: String
  type_contains: String
  type_not_contains: String
  type_starts_with: String
  type_not_starts_with: String
  type_ends_with: String
  type_not_ends_with: String
  x: Int
  x_not: Int
  x_in: [Int!]
  x_not_in: [Int!]
  x_lt: Int
  x_lte: Int
  x_gt: Int
  x_gte: Int
  y: Int
  y_not: Int
  y_in: [Int!]
  y_not_in: [Int!]
  y_lt: Int
  y_lte: Int
  y_gt: Int
  y_gte: Int
  z: Int
  z_not: Int
  z_in: [Int!]
  z_not_in: [Int!]
  z_lt: Int
  z_lte: Int
  z_gt: Int
  z_gte: Int
  rotation: Int
  rotation_not: Int
  rotation_in: [Int!]
  rotation_not_in: [Int!]
  rotation_lt: Int
  rotation_lte: Int
  rotation_gt: Int
  rotation_gte: Int
  inventory: Boolean
  inventory_not: Boolean
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Mutation {
  createBadge(data: BadgeCreateInput!): Badge!
  updateBadge(data: BadgeUpdateInput!, where: BadgeWhereUniqueInput!): Badge
  updateManyBadges(data: BadgeUpdateManyMutationInput!, where: BadgeWhereInput): BatchPayload!
  upsertBadge(where: BadgeWhereUniqueInput!, create: BadgeCreateInput!, update: BadgeUpdateInput!): Badge!
  deleteBadge(where: BadgeWhereUniqueInput!): Badge
  deleteManyBadges(where: BadgeWhereInput): BatchPayload!
  createBan(data: BanCreateInput!): Ban!
  updateBan(data: BanUpdateInput!, where: BanWhereUniqueInput!): Ban
  updateManyBans(data: BanUpdateManyMutationInput!, where: BanWhereInput): BatchPayload!
  upsertBan(where: BanWhereUniqueInput!, create: BanCreateInput!, update: BanUpdateInput!): Ban!
  deleteBan(where: BanWhereUniqueInput!): Ban
  deleteManyBans(where: BanWhereInput): BatchPayload!
  createBot(data: BotCreateInput!): Bot!
  updateBot(data: BotUpdateInput!, where: BotWhereUniqueInput!): Bot
  updateManyBots(data: BotUpdateManyMutationInput!, where: BotWhereInput): BatchPayload!
  upsertBot(where: BotWhereUniqueInput!, create: BotCreateInput!, update: BotUpdateInput!): Bot!
  deleteBot(where: BotWhereUniqueInput!): Bot
  deleteManyBots(where: BotWhereInput): BatchPayload!
  createCatalogFeatured(data: CatalogFeaturedCreateInput!): CatalogFeatured!
  updateCatalogFeatured(data: CatalogFeaturedUpdateInput!, where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  updateManyCatalogFeatureds(data: CatalogFeaturedUpdateManyMutationInput!, where: CatalogFeaturedWhereInput): BatchPayload!
  upsertCatalogFeatured(where: CatalogFeaturedWhereUniqueInput!, create: CatalogFeaturedCreateInput!, update: CatalogFeaturedUpdateInput!): CatalogFeatured!
  deleteCatalogFeatured(where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  deleteManyCatalogFeatureds(where: CatalogFeaturedWhereInput): BatchPayload!
  createCatalogItem(data: CatalogItemCreateInput!): CatalogItem!
  updateCatalogItem(data: CatalogItemUpdateInput!, where: CatalogItemWhereUniqueInput!): CatalogItem
  updateManyCatalogItems(data: CatalogItemUpdateManyMutationInput!, where: CatalogItemWhereInput): BatchPayload!
  upsertCatalogItem(where: CatalogItemWhereUniqueInput!, create: CatalogItemCreateInput!, update: CatalogItemUpdateInput!): CatalogItem!
  deleteCatalogItem(where: CatalogItemWhereUniqueInput!): CatalogItem
  deleteManyCatalogItems(where: CatalogItemWhereInput): BatchPayload!
  createCatalogPage(data: CatalogPageCreateInput!): CatalogPage!
  updateCatalogPage(data: CatalogPageUpdateInput!, where: CatalogPageWhereUniqueInput!): CatalogPage
  updateManyCatalogPages(data: CatalogPageUpdateManyMutationInput!, where: CatalogPageWhereInput): BatchPayload!
  upsertCatalogPage(where: CatalogPageWhereUniqueInput!, create: CatalogPageCreateInput!, update: CatalogPageUpdateInput!): CatalogPage!
  deleteCatalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  deleteManyCatalogPages(where: CatalogPageWhereInput): BatchPayload!
  createChatlog(data: ChatlogCreateInput!): Chatlog!
  updateChatlog(data: ChatlogUpdateInput!, where: ChatlogWhereUniqueInput!): Chatlog
  updateManyChatlogs(data: ChatlogUpdateManyMutationInput!, where: ChatlogWhereInput): BatchPayload!
  upsertChatlog(where: ChatlogWhereUniqueInput!, create: ChatlogCreateInput!, update: ChatlogUpdateInput!): Chatlog!
  deleteChatlog(where: ChatlogWhereUniqueInput!): Chatlog
  deleteManyChatlogs(where: ChatlogWhereInput): BatchPayload!
  createChatlogConsole(data: ChatlogConsoleCreateInput!): ChatlogConsole!
  updateChatlogConsole(data: ChatlogConsoleUpdateInput!, where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  updateManyChatlogConsoles(data: ChatlogConsoleUpdateManyMutationInput!, where: ChatlogConsoleWhereInput): BatchPayload!
  upsertChatlogConsole(where: ChatlogConsoleWhereUniqueInput!, create: ChatlogConsoleCreateInput!, update: ChatlogConsoleUpdateInput!): ChatlogConsole!
  deleteChatlogConsole(where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  deleteManyChatlogConsoles(where: ChatlogConsoleWhereInput): BatchPayload!
  createChatlogConsoleInvitations(data: ChatlogConsoleInvitationsCreateInput!): ChatlogConsoleInvitations!
  updateChatlogConsoleInvitations(data: ChatlogConsoleInvitationsUpdateInput!, where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  updateManyChatlogConsoleInvitationses(data: ChatlogConsoleInvitationsUpdateManyMutationInput!, where: ChatlogConsoleInvitationsWhereInput): BatchPayload!
  upsertChatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!, create: ChatlogConsoleInvitationsCreateInput!, update: ChatlogConsoleInvitationsUpdateInput!): ChatlogConsoleInvitations!
  deleteChatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  deleteManyChatlogConsoleInvitationses(where: ChatlogConsoleInvitationsWhereInput): BatchPayload!
  createHabbo(data: HabboCreateInput!): Habbo!
  updateHabbo(data: HabboUpdateInput!, where: HabboWhereUniqueInput!): Habbo
  updateManyHabboes(data: HabboUpdateManyMutationInput!, where: HabboWhereInput): BatchPayload!
  upsertHabbo(where: HabboWhereUniqueInput!, create: HabboCreateInput!, update: HabboUpdateInput!): Habbo!
  deleteHabbo(where: HabboWhereUniqueInput!): Habbo
  deleteManyHabboes(where: HabboWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createNavigatorCategory(data: NavigatorCategoryCreateInput!): NavigatorCategory!
  updateNavigatorCategory(data: NavigatorCategoryUpdateInput!, where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  updateManyNavigatorCategories(data: NavigatorCategoryUpdateManyMutationInput!, where: NavigatorCategoryWhereInput): BatchPayload!
  upsertNavigatorCategory(where: NavigatorCategoryWhereUniqueInput!, create: NavigatorCategoryCreateInput!, update: NavigatorCategoryUpdateInput!): NavigatorCategory!
  deleteNavigatorCategory(where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  deleteManyNavigatorCategories(where: NavigatorCategoryWhereInput): BatchPayload!
  createNavigatorTab(data: NavigatorTabCreateInput!): NavigatorTab!
  updateNavigatorTab(data: NavigatorTabUpdateInput!, where: NavigatorTabWhereUniqueInput!): NavigatorTab
  updateManyNavigatorTabs(data: NavigatorTabUpdateManyMutationInput!, where: NavigatorTabWhereInput): BatchPayload!
  upsertNavigatorTab(where: NavigatorTabWhereUniqueInput!, create: NavigatorTabCreateInput!, update: NavigatorTabUpdateInput!): NavigatorTab!
  deleteNavigatorTab(where: NavigatorTabWhereUniqueInput!): NavigatorTab
  deleteManyNavigatorTabs(where: NavigatorTabWhereInput): BatchPayload!
  createNews(data: NewsCreateInput!): News!
  updateNews(data: NewsUpdateInput!, where: NewsWhereUniqueInput!): News
  updateManyNewses(data: NewsUpdateManyMutationInput!, where: NewsWhereInput): BatchPayload!
  upsertNews(where: NewsWhereUniqueInput!, create: NewsCreateInput!, update: NewsUpdateInput!): News!
  deleteNews(where: NewsWhereUniqueInput!): News
  deleteManyNewses(where: NewsWhereInput): BatchPayload!
  createRoom(data: RoomCreateInput!): Room!
  updateRoom(data: RoomUpdateInput!, where: RoomWhereUniqueInput!): Room
  updateManyRooms(data: RoomUpdateManyMutationInput!, where: RoomWhereInput): BatchPayload!
  upsertRoom(where: RoomWhereUniqueInput!, create: RoomCreateInput!, update: RoomUpdateInput!): Room!
  deleteRoom(where: RoomWhereUniqueInput!): Room
  deleteManyRooms(where: RoomWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

type NavigatorCategory {
  id: ID!
  name: String
  order: Int
  parent: NavigatorTab
}

type NavigatorCategoryConnection {
  pageInfo: PageInfo!
  edges: [NavigatorCategoryEdge]!
  aggregate: AggregateNavigatorCategory!
}

input NavigatorCategoryCreateInput {
  id: ID
  name: String
  order: Int
  parent: NavigatorTabCreateOneWithoutCategoriesInput
}

input NavigatorCategoryCreateManyWithoutParentInput {
  create: [NavigatorCategoryCreateWithoutParentInput!]
  connect: [NavigatorCategoryWhereUniqueInput!]
}

input NavigatorCategoryCreateWithoutParentInput {
  id: ID
  name: String
  order: Int
}

type NavigatorCategoryEdge {
  node: NavigatorCategory!
  cursor: String!
}

enum NavigatorCategoryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
}

type NavigatorCategoryPreviousValues {
  id: ID!
  name: String
  order: Int
}

input NavigatorCategoryScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  AND: [NavigatorCategoryScalarWhereInput!]
  OR: [NavigatorCategoryScalarWhereInput!]
  NOT: [NavigatorCategoryScalarWhereInput!]
}

type NavigatorCategorySubscriptionPayload {
  mutation: MutationType!
  node: NavigatorCategory
  updatedFields: [String!]
  previousValues: NavigatorCategoryPreviousValues
}

input NavigatorCategorySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigatorCategoryWhereInput
  AND: [NavigatorCategorySubscriptionWhereInput!]
  OR: [NavigatorCategorySubscriptionWhereInput!]
  NOT: [NavigatorCategorySubscriptionWhereInput!]
}

input NavigatorCategoryUpdateInput {
  name: String
  order: Int
  parent: NavigatorTabUpdateOneWithoutCategoriesInput
}

input NavigatorCategoryUpdateManyDataInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateManyMutationInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateManyWithoutParentInput {
  create: [NavigatorCategoryCreateWithoutParentInput!]
  delete: [NavigatorCategoryWhereUniqueInput!]
  connect: [NavigatorCategoryWhereUniqueInput!]
  set: [NavigatorCategoryWhereUniqueInput!]
  disconnect: [NavigatorCategoryWhereUniqueInput!]
  update: [NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput!]
  upsert: [NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput!]
  deleteMany: [NavigatorCategoryScalarWhereInput!]
  updateMany: [NavigatorCategoryUpdateManyWithWhereNestedInput!]
}

input NavigatorCategoryUpdateManyWithWhereNestedInput {
  where: NavigatorCategoryScalarWhereInput!
  data: NavigatorCategoryUpdateManyDataInput!
}

input NavigatorCategoryUpdateWithoutParentDataInput {
  name: String
  order: Int
}

input NavigatorCategoryUpdateWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput!
  data: NavigatorCategoryUpdateWithoutParentDataInput!
}

input NavigatorCategoryUpsertWithWhereUniqueWithoutParentInput {
  where: NavigatorCategoryWhereUniqueInput!
  update: NavigatorCategoryUpdateWithoutParentDataInput!
  create: NavigatorCategoryCreateWithoutParentInput!
}

input NavigatorCategoryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  parent: NavigatorTabWhereInput
  AND: [NavigatorCategoryWhereInput!]
  OR: [NavigatorCategoryWhereInput!]
  NOT: [NavigatorCategoryWhereInput!]
}

input NavigatorCategoryWhereUniqueInput {
  id: ID
}

type NavigatorTab {
  id: ID!
  name: String
  order: Int
  categories(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorCategory!]
}

type NavigatorTabConnection {
  pageInfo: PageInfo!
  edges: [NavigatorTabEdge]!
  aggregate: AggregateNavigatorTab!
}

input NavigatorTabCreateInput {
  id: ID
  name: String
  order: Int
  categories: NavigatorCategoryCreateManyWithoutParentInput
}

input NavigatorTabCreateOneWithoutCategoriesInput {
  create: NavigatorTabCreateWithoutCategoriesInput
  connect: NavigatorTabWhereUniqueInput
}

input NavigatorTabCreateWithoutCategoriesInput {
  id: ID
  name: String
  order: Int
}

type NavigatorTabEdge {
  node: NavigatorTab!
  cursor: String!
}

enum NavigatorTabOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  order_ASC
  order_DESC
}

type NavigatorTabPreviousValues {
  id: ID!
  name: String
  order: Int
}

type NavigatorTabSubscriptionPayload {
  mutation: MutationType!
  node: NavigatorTab
  updatedFields: [String!]
  previousValues: NavigatorTabPreviousValues
}

input NavigatorTabSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NavigatorTabWhereInput
  AND: [NavigatorTabSubscriptionWhereInput!]
  OR: [NavigatorTabSubscriptionWhereInput!]
  NOT: [NavigatorTabSubscriptionWhereInput!]
}

input NavigatorTabUpdateInput {
  name: String
  order: Int
  categories: NavigatorCategoryUpdateManyWithoutParentInput
}

input NavigatorTabUpdateManyMutationInput {
  name: String
  order: Int
}

input NavigatorTabUpdateOneWithoutCategoriesInput {
  create: NavigatorTabCreateWithoutCategoriesInput
  update: NavigatorTabUpdateWithoutCategoriesDataInput
  upsert: NavigatorTabUpsertWithoutCategoriesInput
  delete: Boolean
  disconnect: Boolean
  connect: NavigatorTabWhereUniqueInput
}

input NavigatorTabUpdateWithoutCategoriesDataInput {
  name: String
  order: Int
}

input NavigatorTabUpsertWithoutCategoriesInput {
  update: NavigatorTabUpdateWithoutCategoriesDataInput!
  create: NavigatorTabCreateWithoutCategoriesInput!
}

input NavigatorTabWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  order: Int
  order_not: Int
  order_in: [Int!]
  order_not_in: [Int!]
  order_lt: Int
  order_lte: Int
  order_gt: Int
  order_gte: Int
  categories_every: NavigatorCategoryWhereInput
  categories_some: NavigatorCategoryWhereInput
  categories_none: NavigatorCategoryWhereInput
  AND: [NavigatorTabWhereInput!]
  OR: [NavigatorTabWhereInput!]
  NOT: [NavigatorTabWhereInput!]
}

input NavigatorTabWhereUniqueInput {
  id: ID
  order: Int
}

type News {
  id: ID!
  title: String
  summary: String
  body: String
  image: String
  author: User
  createdAt: DateTime
  updatedAt: DateTime
}

type NewsConnection {
  pageInfo: PageInfo!
  edges: [NewsEdge]!
  aggregate: AggregateNews!
}

input NewsCreateInput {
  id: ID
  title: String
  summary: String
  body: String
  image: String
  author: UserCreateOneInput
}

type NewsEdge {
  node: News!
  cursor: String!
}

enum NewsOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  summary_ASC
  summary_DESC
  body_ASC
  body_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type NewsPreviousValues {
  id: ID!
  title: String
  summary: String
  body: String
  image: String
  createdAt: DateTime
  updatedAt: DateTime
}

type NewsSubscriptionPayload {
  mutation: MutationType!
  node: News
  updatedFields: [String!]
  previousValues: NewsPreviousValues
}

input NewsSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: NewsWhereInput
  AND: [NewsSubscriptionWhereInput!]
  OR: [NewsSubscriptionWhereInput!]
  NOT: [NewsSubscriptionWhereInput!]
}

input NewsUpdateInput {
  title: String
  summary: String
  body: String
  image: String
  author: UserUpdateOneInput
}

input NewsUpdateManyMutationInput {
  title: String
  summary: String
  body: String
  image: String
}

input NewsWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  summary: String
  summary_not: String
  summary_in: [String!]
  summary_not_in: [String!]
  summary_lt: String
  summary_lte: String
  summary_gt: String
  summary_gte: String
  summary_contains: String
  summary_not_contains: String
  summary_starts_with: String
  summary_not_starts_with: String
  summary_ends_with: String
  summary_not_ends_with: String
  body: String
  body_not: String
  body_in: [String!]
  body_not_in: [String!]
  body_lt: String
  body_lte: String
  body_gt: String
  body_gte: String
  body_contains: String
  body_not_contains: String
  body_starts_with: String
  body_not_starts_with: String
  body_ends_with: String
  body_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  author: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [NewsWhereInput!]
  OR: [NewsWhereInput!]
  NOT: [NewsWhereInput!]
}

input NewsWhereUniqueInput {
  id: ID
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  badge(where: BadgeWhereUniqueInput!): Badge
  badges(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Badge]!
  badgesConnection(where: BadgeWhereInput, orderBy: BadgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BadgeConnection!
  ban(where: BanWhereUniqueInput!): Ban
  bans(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Ban]!
  bansConnection(where: BanWhereInput, orderBy: BanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BanConnection!
  bot(where: BotWhereUniqueInput!): Bot
  bots(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Bot]!
  botsConnection(where: BotWhereInput, orderBy: BotOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): BotConnection!
  catalogFeatured(where: CatalogFeaturedWhereUniqueInput!): CatalogFeatured
  catalogFeatureds(where: CatalogFeaturedWhereInput, orderBy: CatalogFeaturedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogFeatured]!
  catalogFeaturedsConnection(where: CatalogFeaturedWhereInput, orderBy: CatalogFeaturedOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogFeaturedConnection!
  catalogItem(where: CatalogItemWhereUniqueInput!): CatalogItem
  catalogItems(where: CatalogItemWhereInput, orderBy: CatalogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogItem]!
  catalogItemsConnection(where: CatalogItemWhereInput, orderBy: CatalogItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogItemConnection!
  catalogPage(where: CatalogPageWhereUniqueInput!): CatalogPage
  catalogPages(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CatalogPage]!
  catalogPagesConnection(where: CatalogPageWhereInput, orderBy: CatalogPageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CatalogPageConnection!
  chatlog(where: ChatlogWhereUniqueInput!): Chatlog
  chatlogs(where: ChatlogWhereInput, orderBy: ChatlogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chatlog]!
  chatlogsConnection(where: ChatlogWhereInput, orderBy: ChatlogOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConnection!
  chatlogConsole(where: ChatlogConsoleWhereUniqueInput!): ChatlogConsole
  chatlogConsoles(where: ChatlogConsoleWhereInput, orderBy: ChatlogConsoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatlogConsole]!
  chatlogConsolesConnection(where: ChatlogConsoleWhereInput, orderBy: ChatlogConsoleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConsoleConnection!
  chatlogConsoleInvitations(where: ChatlogConsoleInvitationsWhereUniqueInput!): ChatlogConsoleInvitations
  chatlogConsoleInvitationses(where: ChatlogConsoleInvitationsWhereInput, orderBy: ChatlogConsoleInvitationsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChatlogConsoleInvitations]!
  chatlogConsoleInvitationsesConnection(where: ChatlogConsoleInvitationsWhereInput, orderBy: ChatlogConsoleInvitationsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatlogConsoleInvitationsConnection!
  habbo(where: HabboWhereUniqueInput!): Habbo
  habboes(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Habbo]!
  habboesConnection(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): HabboConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  navigatorCategory(where: NavigatorCategoryWhereUniqueInput!): NavigatorCategory
  navigatorCategories(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorCategory]!
  navigatorCategoriesConnection(where: NavigatorCategoryWhereInput, orderBy: NavigatorCategoryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigatorCategoryConnection!
  navigatorTab(where: NavigatorTabWhereUniqueInput!): NavigatorTab
  navigatorTabs(where: NavigatorTabWhereInput, orderBy: NavigatorTabOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [NavigatorTab]!
  navigatorTabsConnection(where: NavigatorTabWhereInput, orderBy: NavigatorTabOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NavigatorTabConnection!
  news(where: NewsWhereUniqueInput!): News
  newses(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [News]!
  newsesConnection(where: NewsWhereInput, orderBy: NewsOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): NewsConnection!
  room(where: RoomWhereUniqueInput!): Room
  rooms(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Room]!
  roomsConnection(where: RoomWhereInput, orderBy: RoomOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RoomConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Room {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: [Int!]!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
}

type RoomConnection {
  pageInfo: PageInfo!
  edges: [RoomEdge]!
  aggregate: AggregateRoom!
}

input RoomCreateInput {
  id: ID
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomCreaterightsInput
  items: ItemCreateManyWithoutRoomInput
}

input RoomCreateOneInput {
  create: RoomCreateInput
  connect: RoomWhereUniqueInput
}

input RoomCreateOneWithoutItemsInput {
  create: RoomCreateWithoutItemsInput
  connect: RoomWhereUniqueInput
}

input RoomCreaterightsInput {
  set: [Int!]
}

input RoomCreateWithoutItemsInput {
  id: ID
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomCreaterightsInput
}

type RoomEdge {
  node: Room!
  cursor: String!
}

enum RoomOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  type_ASC
  type_DESC
  category_ASC
  category_DESC
  owner_ASC
  owner_DESC
  map_ASC
  map_DESC
  floorThickness_ASC
  floorThickness_DESC
  wallThickness_ASC
  wallThickness_DESC
  wallHeight_ASC
  wallHeight_DESC
  hideWalls_ASC
  hideWalls_DESC
  hideWired_ASC
  hideWired_DESC
  currentUsers_ASC
  currentUsers_DESC
  maxUsers_ASC
  maxUsers_DESC
  allowPets_ASC
  allowPets_DESC
  allowPetsEating_ASC
  allowPetsEating_DESC
}

type RoomPreviousValues {
  id: ID!
  name: String!
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: [Int!]!
}

type RoomSubscriptionPayload {
  mutation: MutationType!
  node: Room
  updatedFields: [String!]
  previousValues: RoomPreviousValues
}

input RoomSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RoomWhereInput
  AND: [RoomSubscriptionWhereInput!]
  OR: [RoomSubscriptionWhereInput!]
  NOT: [RoomSubscriptionWhereInput!]
}

enum roomType {
  PUBLIC
  LOCKED
  PASSWORD
  HIDDEN
}

input RoomUpdateDataInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
  items: ItemUpdateManyWithoutRoomInput
}

input RoomUpdateInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
  items: ItemUpdateManyWithoutRoomInput
}

input RoomUpdateManyMutationInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
}

input RoomUpdateOneRequiredInput {
  create: RoomCreateInput
  update: RoomUpdateDataInput
  upsert: RoomUpsertNestedInput
  connect: RoomWhereUniqueInput
}

input RoomUpdateOneRequiredWithoutItemsInput {
  create: RoomCreateWithoutItemsInput
  update: RoomUpdateWithoutItemsDataInput
  upsert: RoomUpsertWithoutItemsInput
  connect: RoomWhereUniqueInput
}

input RoomUpdaterightsInput {
  set: [Int!]
}

input RoomUpdateWithoutItemsDataInput {
  name: String
  description: String
  type: roomType
  category: Int
  owner: Int
  map: Json
  floorThickness: Int
  wallThickness: Int
  wallHeight: Int
  hideWalls: Boolean
  hideWired: Boolean
  currentUsers: Int
  maxUsers: Int
  allowPets: Boolean
  allowPetsEating: Boolean
  rights: RoomUpdaterightsInput
}

input RoomUpsertNestedInput {
  update: RoomUpdateDataInput!
  create: RoomCreateInput!
}

input RoomUpsertWithoutItemsInput {
  update: RoomUpdateWithoutItemsDataInput!
  create: RoomCreateWithoutItemsInput!
}

input RoomWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  type: roomType
  type_not: roomType
  type_in: [roomType!]
  type_not_in: [roomType!]
  category: Int
  category_not: Int
  category_in: [Int!]
  category_not_in: [Int!]
  category_lt: Int
  category_lte: Int
  category_gt: Int
  category_gte: Int
  owner: Int
  owner_not: Int
  owner_in: [Int!]
  owner_not_in: [Int!]
  owner_lt: Int
  owner_lte: Int
  owner_gt: Int
  owner_gte: Int
  floorThickness: Int
  floorThickness_not: Int
  floorThickness_in: [Int!]
  floorThickness_not_in: [Int!]
  floorThickness_lt: Int
  floorThickness_lte: Int
  floorThickness_gt: Int
  floorThickness_gte: Int
  wallThickness: Int
  wallThickness_not: Int
  wallThickness_in: [Int!]
  wallThickness_not_in: [Int!]
  wallThickness_lt: Int
  wallThickness_lte: Int
  wallThickness_gt: Int
  wallThickness_gte: Int
  wallHeight: Int
  wallHeight_not: Int
  wallHeight_in: [Int!]
  wallHeight_not_in: [Int!]
  wallHeight_lt: Int
  wallHeight_lte: Int
  wallHeight_gt: Int
  wallHeight_gte: Int
  hideWalls: Boolean
  hideWalls_not: Boolean
  hideWired: Boolean
  hideWired_not: Boolean
  currentUsers: Int
  currentUsers_not: Int
  currentUsers_in: [Int!]
  currentUsers_not_in: [Int!]
  currentUsers_lt: Int
  currentUsers_lte: Int
  currentUsers_gt: Int
  currentUsers_gte: Int
  maxUsers: Int
  maxUsers_not: Int
  maxUsers_in: [Int!]
  maxUsers_not_in: [Int!]
  maxUsers_lt: Int
  maxUsers_lte: Int
  maxUsers_gt: Int
  maxUsers_gte: Int
  allowPets: Boolean
  allowPets_not: Boolean
  allowPetsEating: Boolean
  allowPetsEating_not: Boolean
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  AND: [RoomWhereInput!]
  OR: [RoomWhereInput!]
  NOT: [RoomWhereInput!]
}

input RoomWhereUniqueInput {
  id: ID
}

type Subscription {
  badge(where: BadgeSubscriptionWhereInput): BadgeSubscriptionPayload
  ban(where: BanSubscriptionWhereInput): BanSubscriptionPayload
  bot(where: BotSubscriptionWhereInput): BotSubscriptionPayload
  catalogFeatured(where: CatalogFeaturedSubscriptionWhereInput): CatalogFeaturedSubscriptionPayload
  catalogItem(where: CatalogItemSubscriptionWhereInput): CatalogItemSubscriptionPayload
  catalogPage(where: CatalogPageSubscriptionWhereInput): CatalogPageSubscriptionPayload
  chatlog(where: ChatlogSubscriptionWhereInput): ChatlogSubscriptionPayload
  chatlogConsole(where: ChatlogConsoleSubscriptionWhereInput): ChatlogConsoleSubscriptionPayload
  chatlogConsoleInvitations(where: ChatlogConsoleInvitationsSubscriptionWhereInput): ChatlogConsoleInvitationsSubscriptionPayload
  habbo(where: HabboSubscriptionWhereInput): HabboSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  navigatorCategory(where: NavigatorCategorySubscriptionWhereInput): NavigatorCategorySubscriptionPayload
  navigatorTab(where: NavigatorTabSubscriptionWhereInput): NavigatorTabSubscriptionPayload
  news(where: NewsSubscriptionWhereInput): NewsSubscriptionPayload
  room(where: RoomSubscriptionWhereInput): RoomSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type User {
  id: ID!
  email: String
  password: String
  pin: Int
  habbos(where: HabboWhereInput, orderBy: HabboOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Habbo!]
  createdAt: DateTime
  updatedAt: DateTime
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String
  password: String
  pin: Int
  habbos: HabboCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutHabbosInput {
  create: UserCreateWithoutHabbosInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutHabbosInput {
  id: ID
  email: String
  password: String
  pin: Int
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  pin_ASC
  pin_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String
  password: String
  pin: Int
  createdAt: DateTime
  updatedAt: DateTime
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  password: String
  pin: Int
  habbos: HabboUpdateManyWithoutUserInput
}

input UserUpdateInput {
  email: String
  password: String
  pin: Int
  habbos: HabboUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  pin: Int
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutHabbosInput {
  create: UserCreateWithoutHabbosInput
  update: UserUpdateWithoutHabbosDataInput
  upsert: UserUpsertWithoutHabbosInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutHabbosDataInput {
  email: String
  password: String
  pin: Int
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutHabbosInput {
  update: UserUpdateWithoutHabbosDataInput!
  create: UserCreateWithoutHabbosInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  pin: Int
  pin_not: Int
  pin_in: [Int!]
  pin_not_in: [Int!]
  pin_lt: Int
  pin_lte: Int
  pin_gt: Int
  pin_gte: Int
  habbos_every: HabboWhereInput
  habbos_some: HabboWhereInput
  habbos_none: HabboWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}
`